<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><title>Java基础 | 桃李无言，下自成蹊</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="[object Object]"><meta name="designer" content="minfive"><meta name="keywords" content="ALEGANT,Java,服务端"><meta name="description" content="学习记录和兴趣交流的博客"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><link rel="canonical" href="http://alegant.github.io/2020/04/08/Java%E5%9F%BA%E7%A1%80/index.html"><link rel="icon" type="image/png" href="/img/favicon.ico" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="Alegant's技术博客"><link rel="stylesheet" href="/scss/views/page/post.css"><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Alegant's技术博客" type="application/atom+xml"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(/img/loader.gif)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="Alegant's技术博客" alt="Alegant's技术博客"><img src="/img/logo.png" alt="Alegant's技术博客"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="首页" title="首页">首页</a></li><li class="nav__item"><a href="/archives" alt="归档" title="归档">归档</a></li><li class="nav__item"><a href="/about" alt="关于" title="关于">关于</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="img/Javabase.jpg" alt="Java基础"></div><header class="post__info"><h1 class="post__title">Java基础</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="https://www.github.com/ALEGANT" target="_blank" rel="noopener">ALEGANT</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2020-04-08</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/Java/">Java</a></li><li class="mark__item"><a href="/tags/%E5%9F%BA%E7%A1%80/">基础</a></li><li class="mark__item"><a href="/tags/%E9%9B%86%E5%90%88/">集合</a></li></ul></div></div></header><div class="post__content"><h1 id="Java集合类基础-collection"><a href="#Java集合类基础-collection" class="headerlink" title="Java集合类基础 - collection"></a>Java集合类基础 - collection</h1><p>前言:在讲一些知识点之前先结合这需求来进行剖析，因为代码终究是为需求服务的，这里的需求不仅仅是指产品，就算是程序员也是有需求的，程序员需要一些具体的工具去进行高效率的开发，脱离了需求讲代码其实是不太合理的，就像阐明一件事情要遵守STAR原则一样，要把Situation（情景）、Task（任务）、Action（行动）和Result（结果）结合起来，因此在这里养成个小小的习惯，尽可能地遵守STAR原则。</p><h2 id="地位"><a href="#地位" class="headerlink" title="地位"></a>地位</h2><p>Java的集合类在Java开发过程中占据着重要的角色，无论是架构层面上还是业务层面上，都是不可或缺的重要一环。在架构上，我们常常用Map&lt;String,Class&gt;这样的一个集合去存储类名和它相应的Class,以便于在生产过程中直接通过类名(服务名)去获得相应的对象，或者把符合条件的Class放入列表中统一加载，再或者从业务的角度来看，我们常常需要用集合去实现具体的业务逻辑，例如达成某条件A的人与达成B条件的人的交、并、补集，这些都是可以通过集合去实现的。</p><p>网上关于Collection的内容太多了，在这里我想做的事情是做一些简单的证明和对于源码的解析。而且跟自己立下的规矩一样，我会用代码和图片的形式展现出来。</p><p>对于代码的学习，我的个人习惯是先看继承关系，然后看接口，因为一些类的方法不只是写在这个类本身上，而是写在父类(对于抽象的父类来说，则一般是实现了某个接口，至少有相关方法的声明，否则子类编译会报出”*** must implement the inherited abstract method”的错误)。从这个角度出发，我们来看看Collection这个类。</p><h2 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h2><p><img src="/2020/04/09/Java%E5%9F%BA%E7%A1%80/img/CollectionFrame.png" alt="frame"></p><h2 id="继承树"><a href="#继承树" class="headerlink" title="继承树"></a>继承树</h2><p>关于collection的继承关系，我们可以通过‘进入源码-查询引用’去查看，关于接口也可以在类的声明出找到。以下特性是在jdk1.8的环境下生效。<br><img src="/2020/04/09/Java%E5%9F%BA%E7%A1%80/img/Collection.png" alt="继承图"><br>这里的继承关系是通过观察代码得到的，只引用了java.util包下的集合，可以发现关于源码，设计者们对于每个容器都定义了相应的接口，而且接口之间和类一样有相应的继承关系，在类的定义上层层递进，接口的定义上也是层层递进，最后根据不同的类写出具体的实现方法，这里也体现出设计师面向接口编程的理念。<br>对于AbstractList、AbstractSet、AbstractQueue他们都是继承了AbstractCollection这个类,而AbstractCollection引用了Collection这个接口，因此需要实现这些方法;<br>如下表格:<br>为了称呼方便 我们把参数中的集合称为集合B 调用这个方法的集合称为集合A</p><table><thead><tr><th>接口名</th><th>返回类型</th><th>参数类型</th><th>接口描述</th><th>备注</th></tr></thead><tbody><tr><td>size()</td><td>int</td><td>无</td><td>获得集合大小</td><td></td></tr><tr><td>isEmpty()</td><td>boolean</td><td>无</td><td>判断集合是否为空</td><td></td></tr><tr><td>contains(Object)</td><td>boolean</td><td>Object</td><td>判断集合是否含有该元素</td><td>这里面的参数类型是Object,不会受到声明集合时的泛型限制</td></tr><tr><td>toArray()</td><td>Object[]</td><td>无</td><td>讲集合中的元素转换成对象数组</td><td></td></tr><tr><td>toArray(T[])</td><td><t>T[]</t></td><td>讲集合中的元素转换成泛型数组</td><td>泛型方法</td><td></td></tr><tr><td>add()</td><td>boolean</td><td>E</td><td>向集合中加入元素</td><td>元素E是声明容器时所选用的类型.编译时会检查类型是否匹配.</td></tr><tr><td>remove(Object)</td><td>boolean</td><td>Object</td><td>容器中移除目标元素</td><td>移除的是目标的引用,并不会对对象本身造成影响.</td></tr><tr><td>containsAll(Collection&lt;? extends E&gt;)</td><td>boolean</td><td>Collection&lt;? exteds E&gt;</td><td>判断集合B是否集合A的子集</td><td>这里的参数收到了限制，必须是存放’继承了E的元素’的集合</td></tr><tr><td>addAll(Collection&lt;? extends E&gt;)</td><td>boolean</td><td>Collection&lt;? exteds E&gt;</td><td>将集合B的所有元素加入到集合A中</td><td>参数中的集合存放的对象必须是E类或者E的子类</td></tr><tr><td>removeAll(Collection&lt;?&gt;)</td><td>boolean</td><td>Collection&lt;?&gt;</td><td>移除集合A中所有的集合B的元素</td><td>集合B存放的类型没有限制</td></tr><tr><td>removeIf(Predicate&lt;? super E&gt;)</td><td>boolean</td><td>Predicate&lt;? super E&gt;</td><td>移除集合A中符合条件的元素</td><td>Predicate需要重写评估方法</td></tr><tr><td>clear()</td><td>void</td><td>无</td><td>清空集合</td><td></td></tr><tr><td>equals(Object)</td><td>boolean</td><td>Object</td><td>判断集合是否等价</td><td>根据子类重写的方法判定是值相同还是引用相同</td></tr><tr><td>hashCode()</td><td>int</td><td>无</td><td>获得集合的hashCode</td><td>Object类的方法</td></tr><tr><td>spliterator()</td><td>spliterator</td><td>无</td><td>迭代器</td><td>分割遍历</td></tr><tr><td>Stream()</td><td>Stream</td><td>无</td><td>将集合转换成流</td><td>支持并发</td></tr><tr><td>parllelStream()</td><td>Stream</td><td>无</td><td>将集合转换成流</td><td></td></tr></tbody></table><p>从Collection接口所定义的方法我们可以看出来，Collection就是实现数学中的集合的思想，实现了集合的交并补的逻辑运算，而在具体的方法定义中，我们也可以看出来，在处理集合过程中集合元素的的范围和数学中的集合思想如出一辙。举个例子:</p><hr><p>containsAll(Collection&lt;? extends E&gt;)这个方法,集合B的元素必须是E的子类，类比到数学中就相当于集合B的元素类型必须是集合A的元素类型的子类型。假设A是有理数集，那么B的元素不能是比A的元素(有理数)更高级，但是可以更低级，所以B不能是无理数(比有理数范围大)，可以是自然数(比有理数范围小)，当然集合B(例如说集合B是映射的集合)不能是跟集合A毫无联系的集合，因为这样就毫无可比性。</p><p>Collection的派生接口里面有List、Set、Queue接口，分别和AbstractList、AbstractSet、AbstractQueue相对应。所以只要从这几个接口入手，就等再一次划分这几个集合的区别；</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口:"></a>接口:</h3><p>对于Collection下的各种容器的区分,从”结构决定性质，性质决定用途”的观点出发，我们先要了解这些容器实现了什么接口，才能让这些容器发挥最好的用途。</p><h4 id="List接口"><a href="#List接口" class="headerlink" title="List接口:"></a>List接口:</h4><p>List接口与Collection接口相比增加了下列方法:</p><table><thead><tr><th>接口名</th><th>返回类型</th><th>参数类型</th><th>接口描述</th><th>备注</th></tr></thead><tbody><tr><td>get(int)</td><td>E</td><td>int</td><td>获取对应下标的元素</td><td>获取下表前需要检查</td></tr><tr><td>set(int,E)</td><td>E</td><td>int,E</td><td>设置对应下表的元素</td><td>设置前检查下标</td></tr><tr><td>add(int,E)</td><td>void</td><td>int,E</td><td>对应位置增加元素</td><td></td></tr><tr><td>remove(int)</td><td>E</td><td>int</td><td>移除对应下表的元素</td><td></td></tr><tr><td>subList(int,int)</td><td>List<e></e></td><td>int,int</td><td>切割列表</td><td>注意切割时是直接对列表操作还是对引用进行操作(对存储模板的数据更加要小心)</td></tr><tr><td>indexOf(Object)</td><td>int</td><td>Object</td><td>获取对象在列表中的下标(顺序)</td><td>注意空对象和内部对比对象时的执行方法,一般为参数对象是null会执行==操作,否则执行.equals(element[i])的操作</td></tr><tr><td>lastIndexOf(Object)</td><td>int</td><td>Object</td><td>获取对象在列表中的下标(倒序)</td><td>注意事项同上</td></tr></tbody></table><p>从接口上看来，List容器与下标有着密不可分的关系。</p><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue:"></a>Queue:</h4><table><thead><tr><th>接口名</th><th>返回类型</th><th>参数类型</th><th>接口描述</th><th>备注</th></tr></thead><tbody><tr><td>add(E)</td><td>boolean</td><td>E</td><td>往队列中增加元素</td><td></td></tr><tr><td>offer(E)</td><td>boolean</td><td>E</td><td>往队列中增加元素</td><td>会有增加失败的情况出现</td></tr><tr><td>remove()</td><td>E</td><td>无</td><td>移除队头元素</td><td>如果队列是空会抛出异常</td></tr><tr><td>poll()</td><td>E</td><td>无</td><td>移除队头元素</td><td>如果队列为空会返回null</td></tr><tr><td>element()</td><td>E</td><td>无</td><td>获取队头元素</td><td>只获取不移除，同时如果队列为空会抛出异常</td></tr><tr><td>peek()</td><td>E</td><td>无</td><td>获取队头元素</td><td>只获取不移除，同时如果队列为空会返回null</td></tr></tbody></table><p>从接口上看来,Queue容器不注重下标，但是重视容器的头部。</p><h4 id="Set"><a href="#Set" class="headerlink" title="Set:"></a>Set:</h4><p>Set接口同Collection接口相比几乎一致。唯一不同的是，Set拥有一个子接口SortedSet<e></e></p><h4 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet:"></a>SortedSet<e>:</e></h4><table><thead><tr><th>接口名</th><th>返回类型</th><th>参数类型</th><th>接口描述</th><th>备注</th></tr></thead><tbody><tr><td>comparator()</td><td>Comparator&lt;? super E&gt;</td><td>无</td><td>获得比较器</td><td>SortedSet对Set集合进行了排序操作，需要重写Comparable方法</td></tr><tr><td>subSet(E,E)</td><td>SortedSet<e></e></td><td>E,E</td><td>分组,获取子集</td><td></td></tr><tr><td>headSet(E)</td><td>SortedSet<e></e></td><td>E</td><td>获取大于E的分组</td><td></td></tr><tr><td>tailSet(E)</td><td>SortedSet<e></e></td><td>E</td><td>获取小于E的分组</td><td></td></tr><tr><td>first()</td><td>E</td><td>无</td><td>获取排序后的第一个元素</td><td></td></tr><tr><td>last()</td><td>E</td><td>无</td><td>获取排序后的最后一个元素</td><td></td></tr></tbody></table><p>Map&lt;K,V&gt;:</p><table><thead><tr><th>接口名</th><th>返回类型</th><th>参数类型</th><th>接口描述</th><th>备注</th></tr></thead><tbody><tr><td>size(E)</td><td>int</td><td></td><td>获得map容器的大小</td><td></td></tr><tr><td>isEmpty()</td><td>boolean</td><td></td><td>是否为空</td><td></td></tr><tr><td>containsKey(Object o)</td><td>boolean</td><td>Object</td><td>Key的集合是否包含参数o</td><td></td></tr><tr><td>containsValue(Object o)</td><td>boolean</td><td>Object</td><td>Value的集合是否包含参数o</td><td></td></tr><tr><td>get(Object o)</td><td>V</td><td>Object</td><td>获得参数Key所对应的值</td><td></td></tr><tr><td>put(K k,V v)</td><td>V</td><td>V</td><td>将键值对放入容器中</td><td></td></tr><tr><td>remove(Object o)</td><td>V</td><td>Object</td><td>移除容器中的元素</td><td>如果同个Object对应了不同的Key,删除规则的制订可能有坑.</td></tr><tr><td>putAll(Map&lt;? extends K, ? extends V&gt;)</td><td>无</td><td>Map&lt;? extends K, ? extends V&gt;</td><td>把map容器B的所有元素加入map容器A中</td><td>类型检查</td></tr><tr><td>clear()</td><td>无</td><td>无</td><td>清空map容器中的所有元素</td><td></td></tr><tr><td>keySet()</td><td>Set<k></k></td><td>无</td><td>返回所有Key的集合</td><td>返回的类型是Set，是无序的。</td></tr><tr><td>values()</td><td>Collection<v></v></td><td>无</td><td>返回所有Values的集合</td><td>返回类型是Collection，可以使用Collection接口的所有方法。</td></tr><tr><td>entrySet()</td><td>Set&lt;Entry&lt;K,V&gt;&gt;</td><td>无</td><td>返回所有的键值对</td><td></td></tr><tr><td>equals(Object o)</td><td>boolean</td><td>Object</td><td>判断集合是否等价</td><td></td></tr><tr><td>hashCode()</td><td>int</td><td>无</td><td>获得容器的哈希码</td><td>Object类的方法</td></tr><tr><td>getOrDefault(Object,V)</td><td>V</td><td>Object,V</td><td>获得key所对饮的值，否则返回默认值</td><td>可以防止空指针的问题</td></tr><tr><td>replace(K k, V v)</td><td>V</td><td>K k, V v</td><td>替换原有Key中的value</td><td></td></tr><tr><td>replace(K k, V v, V v)</td><td>boolean</td><td>K k, V v, V v</td><td>替换原有Key中的元素</td><td></td></tr><tr><td>putIfAbsent(K key, V value)</td><td>V</td><td>K key, V value</td><td>往容器中加入键值对，如果已经存在了对应Key则不加入并返回原有的Value</td><td></td></tr><tr><td>remove(Object key, Object value)</td><td>boolean</td><td>Object key, Object value</td><td>移除目标键值对</td><td></td></tr><tr><td>computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction)</td><td>V</td><td>K key, Function&lt;? super K, ? extends V&gt; mappingFunction</td><td>当key存在返回当前value值，key不存在则执行函数并保存到map中</td><td><a href="https://blog.csdn.net/u010938610/article/details/82622144" target="_blank" rel="noopener">参考文章</a></td></tr><tr><td>computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)</td><td>V</td><td>K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction</td><td>指定的 在map中已经存在的key的value进行操作。只对已经存在key的进行操作，否则不操作</td><td><a href="https://blog.csdn.net/u010938610/article/details/82622144" target="_blank" rel="noopener">参考文章</a></td></tr><tr><td>forEach(BiConsumer&lt;? super K, ? super V&gt; action)</td><td>无</td><td>BiConsumer&lt;? super K, ? super V&gt; action</td><td>定义了一个对所有Key和Value操作的接口</td><td></td></tr><tr><td>replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function)</td><td>无</td><td>BiFunction&lt;? super K, ? super V, ? extends V&gt; function</td><td>定义一个可按照自定义规则把新值替换旧值的接口</td><td></td></tr><tr><td>compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)</td><td>V</td><td>K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction</td><td>指定的key在map中的值进行操作 不管存不存在，操作完成后保存到map中</td><td><a href="https://blog.csdn.net/u010938610/article/details/82622144" target="_blank" rel="noopener">参考文章</a></td></tr><tr><td>merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction)</td><td>V</td><td>K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction</td><td>当map中不存在指定的key时，便将传入的value设置为key的值，当key存在值时，执行一个方法该方法接收key的旧值和传入的value，执行自定义的方法返回最终结果设置为key的值。</td><td></td></tr></tbody></table><h5 id="关于Map的接口涉及到jdk8的新特性"><a href="#关于Map的接口涉及到jdk8的新特性" class="headerlink" title="关于Map的接口涉及到jdk8的新特性:"></a>关于Map的接口涉及到jdk8的新特性:</h5><p><a href="https://www.runoob.com/java/java8-new-features.html" target="_blank" rel="noopener">Java8新特性</a>比较常用的几个及教程可以支持函数式编程，虽然可读性没那么强但是写起来比较简洁。</p><h5 id="一些小想法"><a href="#一些小想法" class="headerlink" title="一些小想法:"></a>一些小想法:</h5><p>接口本身就是对类的方法进行抽象，接口继承接口的这种做法以我的理解是对功能进行分级，越具有共性的方法所在的接口的等级就越高，这也是为什么Collection接口是作为一个顶级接口声明的，因为无论是List,Queue,Set这些接口都具备Collection接口所声明的功能，或者我们可以用细胞来类比，接口的继承就类似于细胞的分化，分工逐渐明确。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别:"></a>区别:</h3><p>对于各个容器接下来会按照不同的接口实现来简单的划分，划分的时候会结合源码去说一点细节，对于比较常见的问题就放开不谈。</p><h4 id="List类型的区别"><a href="#List类型的区别" class="headerlink" title="List类型的区别:"></a>List类型的区别:</h4><p>讲在前面的一些方法:</p><hr><p>System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length) (1)</p><hr><p><a href="https://segmentfault.com/a/1190000009922279" target="_blank" rel="noopener">这个</a>面有关于方法的讲解，方法的作用是把”src[srcPos]作为起点把后续的length个位置”替换成以”dest[destPos]作为起点，后续length个元素”的方法。</p><hr><p>ensureCapacityInternal(int minCapacity) (2)</p><p>grow(int minCapacity) (3)</p><hr><p>(2)方法是检测参数是否在列表的的范围内，(3)方法是数组扩容。这个方法会在ArrayList和Vector中被调用。</p><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList:"></a>ArrayList:</h5><p>ArrayList的底层数据结构是数组，有3种构造方式，当使用无参构造时默认长度为10，当使用int做参数时，参数为数组大小，当参数为集合时，内部会调用Collection接口的toArray()方法把集合转成数组。</p><p>既然底层是数组，那么有几个东西需要提前分清楚，length是指底层数组的实际长度，size是容器的一个属性，是表示容器真正存了多少元素的标记，以及index是每个元素所在的位置。(这里先讲清楚，防止后面乱了)</p><p>在ArrayList里面有sort()方法，需要传入比较器，内部会调用Arrays工具类的sort()方法，这里对于工具内部的sort()方法暂不做深究(这个会在本文最后讲工具类Arrays的时候讲解)，主要研究对象还是ArrayList。前面说到ArrayList默认的构造方法会设置10个元素的空位(对应element[])，当插入元素在超过length时，ArrayList会自动扩容，扩大原来的length的1.5倍，从而实现动态长度，为了处理这个问题提供了trimToSize()方法，使得ArrayList可以把尾部多余的null元素剔除。</p><p>indexOf(Object o)和lastIndexOf(Object o)会遍历(分别对应顺序和倒序)一次数组.内部执行equals()方法。</p><p>clone()方法返回了一个对象，克隆是通过数组的复制实现的，属于浅拷贝，同样的toArray()方法也是浅拷贝。同时返回值是Object类型，因此在使用的时候要注意强转，复制好的对象会重置modCount。</p><h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector:"></a>Vector:</h5><p>Vector容器与ArrayList大致相同，但是在线程安全上它在方法上都会有synchronized关键字，说明这个容器是线程安全的；同时Vector的扩容机制与ArrayList不相同，Vector每次扩容容量翻倍。</p><h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList:"></a>LinkedList:</h5><p>linkedList的数据结构是链表，因此在数据的增加与删除上更具有优势(时间复杂度O(1))而在随机查询方面(O(n))性能不如ArrayList。</p><hr><p>LinkedList的get(index)方法会先判断index与size的关系，如果小于size/2就顺序遍历，否则倒序遍历，当数据量大的时候，用for循环去调用get()方法，性能上的损失是非常大的。</p><hr><p>同时在扩容机制上链表更具备优势，链表只需要在’对应下标节点的前一个节点’的next指针指向’被插入的节点’，然后把被插入的节点的next指针指向’原先对应下标节点’就可以完成插入操作，LinkedList还实现了Queue接口，并且在内部拥有Node<e>first和Node<e>last变量，这使得它具有队列的特性。</e></e></p><hr><p>更新分割线2020-04-09</p><hr><div class="post-announce">感谢您的阅读，本文由 <a href="http://ALEGANT.github.io">Alegant's技术博客</a> 版权所有。如若转载，请注明出处：Alegant's技术博客（<a href="http://ALEGANT.github.io/2020/04/08/Java%E5%9F%BA%E7%A1%80/">http://ALEGANT.github.io/2020/04/08/Java%E5%9F%BA%E7%A1%80/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/2020/04/08/HelloWorld/" title="Hello World"><i class="iconfont icon-prev"></i>Hello World</a></div><div class="post__prev post__prev--right"></div></div></div></article></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">简介</h3><p class="block__text">学习记录和兴趣交流的博客</p></div><div class="sidebar__block"><h3 class="block__title">文章分类</h3></div><div class="sidebar__block"><h3 class="block__title">最新文章</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2020/04/08/Java%E5%9F%BA%E7%A1%80/" title="Java基础"><div class="item__cover"><img src="img/Javabase.jpg" alt="Java基础"></div><div class="item__info"><h3 class="item__title">Java基础</h3><span class="item__text">2020-04-08</span></div></a></li><li class="latest-post-item"><a href="/2020/04/08/HelloWorld/" title="Hello World"><div class="item__cover"><img src="img/helloworld.jpg" alt="Hello World"></div><div class="item__info"><h3 class="item__title">Hello World</h3><span class="item__text">2020-04-08</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">文章标签</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/Java/">Java</a></li><li class="tag-item"><a class="tag-link" href="/tags/helloWorld/">helloWorld</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E5%9F%BA%E7%A1%80/">基础</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E7%AE%80%E4%BB%8B/">简介</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E9%9B%86%E5%90%88/">集合</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">关于</h3><div class="item__content"><p class="item__text">本站是基于 Hexo 搭建的静态资源博客，主要用于分享日常学习、生活及工作的一些心得总结。</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>SHENZHEN, Guangdong Province, China</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>736065863@qq.com</span></li></ul></div></div><div class="footer-top__item footer__image"><img src="/img/avatar.png" alt="logo" title="Alegant's技术博客"></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">CopyRight © made by <a href="https://github.com/ALEGANT" target="_blank">ALEGANT</a>, ©theme <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2017 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, made by <a href="https://github.com/Mrminfive" target="_blank">minfive</a>.</p><ul class="footer__social-network clearfix"><li class="social-network__item"><a href="https://github.com/ALEGANT" target="_blank" title="github"><i class="iconfont icon-github"></i></a></li><li class="social-network__item"><a href="mailto:736065863@qq.com" target="_blank" title="email"><i class="iconfont icon-email"></i></a></li></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>