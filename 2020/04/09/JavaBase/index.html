<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><title>Java基础 | 桃李无言，下自成蹊</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="[object Object]"><meta name="designer" content="minfive"><meta name="keywords" content="ALEGANT,Java,服务端"><meta name="description" content="学习记录和兴趣交流的博客"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><link rel="canonical" href="http://alegant.github.io/2020/04/09/JavaBase/index.html"><link rel="icon" type="image/png" href="/img/favicon.ico" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="Alegant's技术博客"><link rel="stylesheet" href="/scss/views/page/post.css"><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Alegant's技术博客" type="application/atom+xml"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(/img/loader.gif)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="Alegant's技术博客" alt="Alegant's技术博客"><img src="/img/logo.png" alt="Alegant's技术博客"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="首页" title="首页">首页</a></li><li class="nav__item"><a href="/archives" alt="归档" title="归档">归档</a></li><li class="nav__item"><a href="/about" alt="关于" title="关于">关于</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="img/Javabase.jpg" alt="Java基础"></div><header class="post__info"><h1 class="post__title">Java基础</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="https://www.github.com/ALEGANT" target="_blank" rel="noopener">ALEGANT</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2020-04-09</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/Java/">Java</a></li><li class="mark__item"><a href="/tags/%E5%9F%BA%E7%A1%80/">基础</a></li><li class="mark__item"><a href="/tags/%E9%9B%86%E5%90%88/">集合</a></li></ul></div></div></header><div class="post__content"><h1 id="Java集合类基础-collection"><a href="#Java集合类基础-collection" class="headerlink" title="Java集合类基础 - collection"></a>Java集合类基础 - collection</h1><p>前言:在讲一些知识点之前先结合这需求来进行剖析，因为代码终究是为需求服务的，这里的需求不仅仅是指产品，就算是程序员也是有需求的，程序员需要一些具体的工具去进行高效率的开发，脱离了需求讲代码其实是不太合理的，就像阐明一件事情要遵守STAR原则一样，要把Situation（情景）、Task（任务）、Action（行动）和Result（结果）结合起来，因此在这里养成个小小的习惯，尽可能地遵守STAR原则。</p><p>目录:</p><p><a href="#整体框架">整体框架</a></p><p><a href="#继承树">继承树</a></p><p><a href="#Collection接口">Collection接口</a></p><p><a href="#Map接口">Map接口</a></p><p><a href="#AbstractCollection下的区别">AbstractCollection下的区别</a></p><p>-<a href="#AbstractList下的区别">AbstractList下的区别</a></p><p>-<a href="#AbstractQueue类型的区别">AbstractQueue类型的区别</a></p><p>-<a href="#AbstractSet类型的区别">AbstractSet类型的区别</a></p><p><a href="#AbstractMap类型的区别">AbstractMap类型的区别</a></p><p><a href="#两个特殊的结构">两个特殊的结构</a></p><h2 id="地位"><a href="#地位" class="headerlink" title="地位"></a>地位</h2><p>Java的集合类在Java开发过程中占据着重要的角色，无论是架构层面上还是业务层面上，都是不可或缺的重要一环。在架构上，我们常常用Map&lt;String,Class&gt;这样的一个集合去存储类名和它相应的Class,以便于在生产过程中直接通过类名(服务名)去获得相应的对象，或者把符合条件的Class放入列表中统一加载，再或者从业务的角度来看，我们常常需要用集合去实现具体的业务逻辑，例如达成某条件A的人与达成B条件的人的交、并、补集，这些都是可以通过集合去实现的。</p><p>网上关于Collection的内容太多了，在这里我想做的事情是做一些简单的证明和对于源码的解析。而且跟自己立下的规矩一样，我会用代码和图片的形式展现出来。</p><p>对于代码的学习，我的个人习惯是先看继承关系，然后看接口，因为一些类的方法不只是写在这个类本身上，而是写在父类(对于抽象的父类来说，则一般是实现了某个接口，至少有相关方法的声明，否则子类编译会报出”*** must implement the inherited abstract method”的错误)。从这个角度出发，我们来看看Collection这个类。</p><h2 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h2><p><img src="/2020/04/09/JavaBase/img/Collection.png" alt="frame"></p><h3 id="继承树"><a href="#继承树" class="headerlink" title="继承树"></a>继承树</h3><p>关于collection的继承关系，我们可以通过‘进入源码-查询引用’去查看，关于接口也可以在类的声明出找到。以下特性是在jdk1.8的环境下生效。<br><img src="/2020/04/09/JavaBase/img/CollectionFrame.png" alt="继承图"><br>这里的继承关系是通过观察代码得到的，只引用了java.util包下的集合，可以发现关于源码，设计者们对于每个容器都定义了相应的接口，而且接口之间和类一样有相应的继承关系，在类的定义上层层递进，接口的定义上也是层层递进，最后根据不同的类写出具体的实现方法，这里也体现出设计师面向接口编程的理念。<br>对于AbstractList、AbstractSet、AbstractQueue他们都是继承了AbstractCollection这个类,而AbstractCollection引用了Collection这个接口，因此需要实现这些方法;<br>如下表格:<br>为了称呼方便 我们把参数中的集合称为集合B 调用这个方法的集合称为集合A</p><table><thead><tr><th>接口名</th><th>返回类型</th><th>参数类型</th><th>接口描述</th><th>备注</th></tr></thead><tbody><tr><td>size()</td><td>int</td><td>无</td><td>获得集合大小</td><td></td></tr><tr><td>isEmpty()</td><td>boolean</td><td>无</td><td>判断集合是否为空</td><td></td></tr><tr><td>contains(Object)</td><td>boolean</td><td>Object</td><td>判断集合是否含有该元素</td><td>这里面的参数类型是Object,不会受到声明集合时的泛型限制</td></tr><tr><td>toArray()</td><td>Object[]</td><td>无</td><td>讲集合中的元素转换成对象数组</td><td></td></tr><tr><td>toArray(T[])</td><td><t>T[]</t></td><td>讲集合中的元素转换成泛型数组</td><td>泛型方法</td><td></td></tr><tr><td>add()</td><td>boolean</td><td>E</td><td>向集合中加入元素</td><td>元素E是声明容器时所选用的类型.编译时会检查类型是否匹配.</td></tr><tr><td>remove(Object)</td><td>boolean</td><td>Object</td><td>容器中移除目标元素</td><td>移除的是目标的引用,并不会对对象本身造成影响.</td></tr><tr><td>containsAll(Collection&lt;? extends E&gt;)</td><td>boolean</td><td>Collection&lt;? exteds E&gt;</td><td>判断集合B是否集合A的子集</td><td>这里的参数收到了限制，必须是存放’继承了E的元素’的集合</td></tr><tr><td>addAll(Collection&lt;? extends E&gt;)</td><td>boolean</td><td>Collection&lt;? exteds E&gt;</td><td>将集合B的所有元素加入到集合A中</td><td>参数中的集合存放的对象必须是E类或者E的子类</td></tr><tr><td>removeAll(Collection&lt;?&gt;)</td><td>boolean</td><td>Collection&lt;?&gt;</td><td>移除集合A中所有的集合B的元素</td><td>集合B存放的类型没有限制</td></tr><tr><td>removeIf(Predicate&lt;? super E&gt;)</td><td>boolean</td><td>Predicate&lt;? super E&gt;</td><td>移除集合A中符合条件的元素</td><td>Predicate需要重写评估方法</td></tr><tr><td>clear()</td><td>void</td><td>无</td><td>清空集合</td><td></td></tr><tr><td>equals(Object)</td><td>boolean</td><td>Object</td><td>判断集合是否等价</td><td>根据子类重写的方法判定是值相同还是引用相同</td></tr><tr><td>hashCode()</td><td>int</td><td>无</td><td>获得集合的hashCode</td><td>Object类的方法</td></tr><tr><td>spliterator()</td><td>spliterator</td><td>无</td><td>迭代器</td><td>分割遍历</td></tr><tr><td>Stream()</td><td>Stream</td><td>无</td><td>将集合转换成流</td><td>支持并发</td></tr><tr><td>parllelStream()</td><td>Stream</td><td>无</td><td>将集合转换成流</td><td></td></tr></tbody></table><p>从Collection接口所定义的方法我们可以看出来，Collection就是实现数学中的集合的思想，实现了集合的交并补的逻辑运算，而在具体的方法定义中，我们也可以看出来，在处理集合过程中集合元素的的范围和数学中的集合思想如出一辙。举个例子:</p><hr><p>containsAll(Collection&lt;? extends E&gt;)这个方法,集合B的元素必须是E的子类，类比到数学中就相当于集合B的元素类型必须是集合A的元素类型的子类型。假设A是有理数集，那么B的元素不能是比A的元素(有理数)更高级，但是可以更低级，所以B不能是无理数(比有理数范围大)，可以是自然数(比有理数范围小)，当然集合B(例如说集合B是映射的集合)不能是跟集合A毫无联系的集合，因为这样就毫无可比性。</p><p>Collection的派生接口里面有List、Set、Queue接口，分别和AbstractList、AbstractSet、AbstractQueue相对应。所以只要从这几个接口入手，就等再一次划分这几个集合的区别；</p><h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口:"></a>Collection接口:</h3><p>对于Collection下的各种容器的区分,从”结构决定性质，性质决定用途”的观点出发，我们先要了解这些容器实现了什么接口，才能让这些容器发挥最好的用途。</p><h4 id="List"><a href="#List" class="headerlink" title="List:"></a>List:</h4><p>List接口与Collection接口相比增加了下列方法:</p><table><thead><tr><th>接口名</th><th>返回类型</th><th>参数类型</th><th>接口描述</th><th>备注</th></tr></thead><tbody><tr><td>get(int)</td><td>E</td><td>int</td><td>获取对应下标的元素</td><td>获取下表前需要检查</td></tr><tr><td>set(int,E)</td><td>E</td><td>int,E</td><td>设置对应下表的元素</td><td>设置前检查下标</td></tr><tr><td>add(int,E)</td><td>void</td><td>int,E</td><td>对应位置增加元素</td><td></td></tr><tr><td>remove(int)</td><td>E</td><td>int</td><td>移除对应下表的元素</td><td></td></tr><tr><td>subList(int,int)</td><td>List<e></e></td><td>int,int</td><td>切割列表</td><td>注意切割时是直接对列表操作还是对引用进行操作(对存储模板的数据更加要小心)</td></tr><tr><td>indexOf(Object)</td><td>int</td><td>Object</td><td>获取对象在列表中的下标(顺序)</td><td>注意空对象和内部对比对象时的执行方法,一般为参数对象是null会执行==操作,否则执行.equals(element[i])的操作</td></tr><tr><td>lastIndexOf(Object)</td><td>int</td><td>Object</td><td>获取对象在列表中的下标(倒序)</td><td>注意事项同上</td></tr></tbody></table><p>从接口上看来，List容器与下标有着密不可分的关系。</p><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue:"></a>Queue:</h4><table><thead><tr><th>接口名</th><th>返回类型</th><th>参数类型</th><th>接口描述</th><th>备注</th></tr></thead><tbody><tr><td>add(E)</td><td>boolean</td><td>E</td><td>往队列中增加元素</td><td></td></tr><tr><td>offer(E)</td><td>boolean</td><td>E</td><td>往队列中增加元素</td><td>会有增加失败的情况出现</td></tr><tr><td>remove()</td><td>E</td><td>无</td><td>移除队头元素</td><td>如果队列是空会抛出异常</td></tr><tr><td>poll()</td><td>E</td><td>无</td><td>移除队头元素</td><td>如果队列为空会返回null</td></tr><tr><td>element()</td><td>E</td><td>无</td><td>获取队头元素</td><td>只获取不移除，同时如果队列为空会抛出异常</td></tr><tr><td>peek()</td><td>E</td><td>无</td><td>获取队头元素</td><td>只获取不移除，同时如果队列为空会返回null</td></tr></tbody></table><p>从接口上看来,Queue容器不注重下标，但是重视容器的头部。</p><h4 id="Set"><a href="#Set" class="headerlink" title="Set:"></a>Set:</h4><p>Set接口同Collection接口相比几乎一致。唯一不同的是，Set拥有一个子接口SortedSet<e></e></p><h4 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet:"></a>SortedSet<e>:</e></h4><table><thead><tr><th>接口名</th><th>返回类型</th><th>参数类型</th><th>接口描述</th><th>备注</th></tr></thead><tbody><tr><td>comparator()</td><td>Comparator&lt;? super E&gt;</td><td>无</td><td>获得比较器</td><td>SortedSet对Set集合进行了排序操作，需要重写Comparable方法</td></tr><tr><td>subSet(E,E)</td><td>SortedSet<e></e></td><td>E,E</td><td>分组,获取子集</td><td></td></tr><tr><td>headSet(E)</td><td>SortedSet<e></e></td><td>E</td><td>获取大于E的分组</td><td></td></tr><tr><td>tailSet(E)</td><td>SortedSet<e></e></td><td>E</td><td>获取小于E的分组</td><td></td></tr><tr><td>first()</td><td>E</td><td>无</td><td>获取排序后的第一个元素</td><td></td></tr><tr><td>last()</td><td>E</td><td>无</td><td>获取排序后的最后一个元素</td><td></td></tr></tbody></table><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口:"></a>Map接口:</h3><table><thead><tr><th>接口名</th><th>返回类型</th><th>参数类型</th><th>接口描述</th><th>备注</th></tr></thead><tbody><tr><td>size(E)</td><td>int</td><td></td><td>获得map容器的大小</td><td></td></tr><tr><td>isEmpty()</td><td>boolean</td><td></td><td>是否为空</td><td></td></tr><tr><td>containsKey(Object o)</td><td>boolean</td><td>Object</td><td>Key的集合是否包含参数o</td><td></td></tr><tr><td>containsValue(Object o)</td><td>boolean</td><td>Object</td><td>Value的集合是否包含参数o</td><td></td></tr><tr><td>get(Object o)</td><td>V</td><td>Object</td><td>获得参数Key所对应的值</td><td></td></tr><tr><td>put(K k,V v)</td><td>V</td><td>V</td><td>将键值对放入容器中</td><td></td></tr><tr><td>remove(Object o)</td><td>V</td><td>Object</td><td>移除容器中的元素</td><td>参数中的Object与Key对应</td></tr><tr><td>putAll(Map&lt;? extends K, ? extends V&gt;)</td><td>无</td><td>Map&lt;? extends K, ? extends V&gt;</td><td>把map容器B的所有元素加入map容器A中</td><td>类型检查</td></tr><tr><td>clear()</td><td>无</td><td>无</td><td>清空map容器中的所有元素</td><td></td></tr><tr><td>keySet()</td><td>Set<k></k></td><td>无</td><td>返回所有Key的集合</td><td>返回的类型是Set，是无序的。</td></tr><tr><td>values()</td><td>Collection<v></v></td><td>无</td><td>返回所有Values的集合</td><td>返回类型是Collection，可以使用Collection接口的所有方法。</td></tr><tr><td>entrySet()</td><td>Set&lt;Entry&lt;K,V&gt;&gt;</td><td>无</td><td>返回所有的键值对</td><td></td></tr><tr><td>equals(Object o)</td><td>boolean</td><td>Object</td><td>判断集合是否等价</td><td></td></tr><tr><td>hashCode()</td><td>int</td><td>无</td><td>获得容器的哈希码</td><td>Object类的方法</td></tr><tr><td>getOrDefault(Object,V)</td><td>V</td><td>Object,V</td><td>获得key所对饮的值，否则返回默认值</td><td>可以防止空指针的问题</td></tr><tr><td>replace(K k, V v)</td><td>V</td><td>K k, V v</td><td>替换原有Key中的value</td><td></td></tr><tr><td>replace(K k, V v, V v)</td><td>boolean</td><td>K k, V v, V v</td><td>替换原有Key中的元素</td><td></td></tr><tr><td>putIfAbsent(K key, V value)</td><td>V</td><td>K key, V value</td><td>往容器中加入键值对，如果已经存在了对应Key则不加入并返回原有的Value</td><td></td></tr><tr><td>remove(Object key, Object value)</td><td>boolean</td><td>Object key, Object value</td><td>移除目标键值对</td><td></td></tr><tr><td>computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction)</td><td>V</td><td>K key, Function&lt;? super K, ? extends V&gt; mappingFunction</td><td>当key存在返回当前value值，key不存在则执行函数并保存到map中</td><td><a href="https://blog.csdn.net/u010938610/article/details/82622144" target="_blank" rel="noopener">参考文章</a></td></tr><tr><td>computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)</td><td>V</td><td>K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction</td><td>指定的 在map中已经存在的key的value进行操作。只对已经存在key的进行操作，否则不操作</td><td><a href="https://blog.csdn.net/u010938610/article/details/82622144" target="_blank" rel="noopener">参考文章</a></td></tr><tr><td>forEach(BiConsumer&lt;? super K, ? super V&gt; action)</td><td>无</td><td>BiConsumer&lt;? super K, ? super V&gt; action</td><td>定义了一个对所有Key和Value操作的接口</td><td></td></tr><tr><td>replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function)</td><td>无</td><td>BiFunction&lt;? super K, ? super V, ? extends V&gt; function</td><td>定义一个可按照自定义规则把新值替换旧值的接口</td><td></td></tr><tr><td>compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)</td><td>V</td><td>K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction</td><td>指定的key在map中的值进行操作 不管存不存在，操作完成后保存到map中</td><td><a href="https://blog.csdn.net/u010938610/article/details/82622144" target="_blank" rel="noopener">参考文章</a></td></tr><tr><td>merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction)</td><td>V</td><td>K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction</td><td>当map中不存在指定的key时，便将传入的value设置为key的值，当key存在值时，执行一个方法该方法接收key的旧值和传入的value，执行自定义的方法返回最终结果设置为key的值。</td><td></td></tr></tbody></table><h4 id="关于Map的接口涉及到jdk8的新特性"><a href="#关于Map的接口涉及到jdk8的新特性" class="headerlink" title="关于Map的接口涉及到jdk8的新特性:"></a>关于Map的接口涉及到jdk8的新特性:</h4><p><a href="https://www.runoob.com/java/java8-new-features.html" target="_blank" rel="noopener">Java8新特性</a>比较常用的几个及教程可以支持函数式编程，虽然可读性没那么强但是写起来比较简洁。</p><h4 id="一些小想法"><a href="#一些小想法" class="headerlink" title="一些小想法:"></a>一些小想法:</h4><p>接口本身就是对类的方法进行抽象，接口继承接口的这种做法以我的理解是对功能进行分级，越具有共性的方法所在的接口的等级就越高，这也是为什么Collection接口是作为一个顶级接口声明的，因为无论是List,Queue,Set这些接口都具备Collection接口所声明的功能，或者我们可以用细胞来类比，接口的继承就类似于细胞的分化，分工逐渐明确。</p><h3 id="AbstractCollection下的区别"><a href="#AbstractCollection下的区别" class="headerlink" title="AbstractCollection下的区别:"></a>AbstractCollection下的区别:</h3><p>对于各个容器接下来会按照不同的接口实现来简单的划分，划分的时候会结合源码去说一点细节，对于比较常见的问题就放开不谈。</p><h4 id="AbstractList类型的区别"><a href="#AbstractList类型的区别" class="headerlink" title="AbstractList类型的区别:"></a>AbstractList类型的区别:</h4><p>讲在前面的一些方法:</p><hr><p>System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length) (1)</p><hr><p><a href="https://segmentfault.com/a/1190000009922279" target="_blank" rel="noopener">这里</a>有关于方法的讲解，方法的作用是把”src[srcPos]作为起点把后续的length个位置”替换成以”dest[destPos]作为起点，后续length个元素”的方法。</p><hr><p>ensureCapacityInternal(int minCapacity) (2)</p><p>grow(int minCapacity) (3)</p><hr><p>(2)方法是检测参数是否在列表的的范围内，(3)方法是数组扩容。这个方法会在ArrayList和Vector中被调用。</p><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList:"></a>ArrayList:</h5><p>ArrayList的底层数据结构是数组，有3种构造方式，当使用无参构造时默认长度为10，当使用int做参数时，参数为数组大小，当参数为集合时，内部会调用Collection接口的toArray()方法把集合转成数组。</p><p>既然底层是数组，那么有几个东西需要提前分清楚，length是指底层数组的实际长度，size是容器的一个属性，是表示容器真正存了多少元素的标记，以及index是每个元素所在的位置。(这里先讲清楚，防止后面乱了)</p><p>在ArrayList里面有sort()方法，需要传入比较器，内部会调用Arrays工具类的sort()方法，这里对于工具内部的sort()方法暂不做深究(这个会在本文最后讲工具类Arrays的时候讲解)，主要研究对象还是ArrayList。前面说到ArrayList默认的构造方法会设置10个元素的空位(对应element[])，当插入元素在超过length时，ArrayList会自动扩容，扩大原来的length的1.5倍，从而实现动态长度，因为这里已经经过了扩容，可以确保数组的长度足够，因此不用在内部使用for循环来调用add(index,e)方法从而提高性能，为了处理这个问题提供了trimToSize()方法，使得ArrayList可以把尾部多余的null元素剔除。</p><p>indexOf(Object o)和lastIndexOf(Object o)会遍历(分别对应顺序和倒序)一次数组.内部执行equals()方法。</p><p>clone()方法返回了一个对象，克隆是通过数组的复制实现的，属于浅拷贝，同样的toArray()方法也是浅拷贝。同时返回值是Object类型，因此在使用的时候要注意强转，复制好的对象会重置modCount。</p><h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector:"></a>Vector:</h5><p>Vector容器与ArrayList大致相同，但是在线程安全上它在方法上都会有synchronized关键字，说明这个容器是线程安全的；同时Vector的扩容机制与ArrayList不相同，Vector每次扩容容量翻倍。</p><h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList:"></a>LinkedList:</h5><p>linkedList的数据结构是链表，因此在数据的增加与删除上更具有优势(时间复杂度O(1))而在随机查询方面(O(n))性能不如ArrayList。</p><p>LinkedList的get(index)方法会先判断index与size的关系，如果小于size/2就顺序遍历，否则倒序遍历，当数据量大的时候，用for循环去调用get()方法，性能上的损失是非常大的。</p><p>同时在扩容机制上链表更具备优势，链表只需要在’对应下标节点的前一个节点’的next指针指向’被插入的节点’，然后把被插入的节点的next指针指向’原先对应下标节点’就可以完成插入操作，LinkedList还实现了Queue接口，并且在内部拥有Node<e>first和Node<e>last变量，这使得它具有队列的特性。</e></e></p><hr><p>更新分割线2020-04-09,后续继续更新</p><p>写完结构发现这个主题要写完的话需要大量时间，现在先把讲解的框架定好，后续再持续更新，按照接触到的顺序和常用程度进行不定期更新。</p><hr><h4 id="AbstractQueue类型的区别"><a href="#AbstractQueue类型的区别" class="headerlink" title="AbstractQueue类型的区别:"></a>AbstractQueue类型的区别:</h4><h5 id="AsLIFOQueue"><a href="#AsLIFOQueue" class="headerlink" title="AsLIFOQueue:"></a>AsLIFOQueue:</h5><h5 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue:"></a>PriorityQueue:</h5><h4 id="Concurrent包下的Queue"><a href="#Concurrent包下的Queue" class="headerlink" title="Concurrent包下的Queue:"></a>Concurrent包下的Queue:</h4><h5 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue:"></a>ArrayBlockingQueue:</h5><h5 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue:"></a>ConcurrentLinkedQueue:</h5><h5 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue:"></a>DelayQueue:</h5><h5 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue:"></a>LinkedBlockingQueue:</h5><h5 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue:"></a>LinkedTransferQueue:</h5><h5 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue:"></a>PriorityBlockingQueue:</h5><h5 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue:"></a>SynchronousQueue:</h5><h4 id="AbstractSet类型的区别"><a href="#AbstractSet类型的区别" class="headerlink" title="AbstractSet类型的区别:"></a>AbstractSet类型的区别:</h4><h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet:"></a>HashSet:</h5><h5 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet:"></a>LinkedHashSet:</h5><h5 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet:"></a>TreeSet:</h5><h4 id="AbstractMap类型的区别"><a href="#AbstractMap类型的区别" class="headerlink" title="AbstractMap类型的区别:"></a>AbstractMap类型的区别:</h4><h5 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap:"></a>HashMap:</h5><p>HashMap是生产过程中基本不会离开的一种数据结构，也是最有典型意义的键值对类型。</p><p>在jdk1.7的时候，HashMap的内部结构是以Entry&lt;K,V&gt;作为元素，以数组+链表作为结构，当我们往hash表中添加一个对象时，会调用对象的hashcode()方法，算出对应的数组的索引值，再根据索引值查找数组，数组中是否存在对象，如果不存在对象直接存进去。如果存在对象(即两个对象的HashCode相等，但是不是同个对象，这个现象成为碰撞)，则通过euqals()方法比较两个对象的key值是否相等，如果相等则覆盖value值，否则产生链表并对链表内的元素进行逐个比较，通过这个方法，减少了equals()方法的使用次数从而提高性能。</p><p>在Jdk1.8时，HashMap的内部结构是Node&lt;K,V&gt;，以数组+链表+RBTree(一种树状的数据结构，由二叉搜索树衍生，特点是左节点小于根节点，右节点大于根节点)作为结构，原理和1.7差不多，在map长度超过64时就会进行树化改造，将链表转换成BRTree，这个做法通过牺牲了插入和删除的性能提高了查找的性能，因为RBTree的插入比较复杂，时间复杂度是大于链表的。(关于红黑树的具体细节我会在后续算法相关的文章中讲解)</p><p>在HashMap生成时，会设置负载因子，这个负载因子的默认值是0.75。0.75这个数字是对时间与空间的折衷，如果取1，则空间使用率达到最高，但是冲突的机会更大，如果小了，碰撞就会减少，但是会浪费空间。简而言之：负载因子越大，冲突机会越大，查找成本越大，空间利用率高，反之负载银子越小，冲突机会越小，查找成本越小，空间利用率越低。</p><p>讲在前面的方法:</p><p>resize():</p><hr><p>因为jdk1.8对HashMap进行了优化</p><p>jdk1.7:</p><p>存放新值时发生了hash碰撞，同时size++大于等于阈值时会扩容。</p><p>扩容时会用transfer()方法把原数组的值放入新数组，然后设置新的阈值。(桶满了，换个大点的桶装)</p><p>其中这里的transfer()方法会对原来的数组进行遍历，如果数组的元素产生了链表，则对这个链表的每个元素进行rehash，重新计算哈希值，从而把链表中的元素分布到数组里，从而减少链表的数量提高查询性能。</p><p>注意如果当前容量已经达到最大时不扩容。</p><p>但是在多线程的环境下，如果多个线程访问了同一个HashMap，就会出现死循环的问题，具体<a href="https://blog.csdn.net/maohoo/article/details/81531925" target="_blank" rel="noopener">死循环的原因</a>。</p><p>jdk1.8:</p><p>jdk1.8的resize()方法前部分的判断和jdk1.7的判断大致相同，同时把transfer()部分的代码合并到resize()方法里，因为增加了红黑树的结构，transfer()方法的变动比较大，当桶中只有节点数为1时，重新计算节点的散列，使其分布到其它位置，如果桶中节点数大于1，此时重新区分情况，当桶中是链表时，会把链表一分为二，使得原来的桶里一半的节点保留在原桶，另外一半的元素分布到之前所在桶的下标+oldCap，即转移到原有下标+原来的size，区分条件是用Hash值与扩容前的size做与运算；当桶中是红黑树时，需要对它进行拆分，形成链表，然后再同样地会遍历链表节点后将部分元素映射到新桶里。</p><p>hash():</p><hr><p>jdk1.7的hash算法就是简单地key mod table.length。</p><p>jdk1.8的hash算法是key取出key的hashCode的高16位然后与自身异或，从而得到数组下标。为了散布更均匀，因此不用&amp;使得结果偏向0或者使用|使得结果偏向1。</p><p>讲完了前面的方法我们再回过头来看，HashMap的定义方式和Collection的方式类似，一种是无参构造，无参构造会默认生成大小为16，负载因子0.75的HashMap。另外一种是以Map为参数的构造方式则会调用putMapEntries()方法，在这个方法里会重新计算Map的阈值和设定数组的大小，具体做法是把当前的size - 1,然后与自身的右移1、2、4、8、16位做或运算，得出新的阈值，如果map的大小大于阈值则进行resize()，通过putVal()方法把参数的所有节点加入到散列中。</p><p>putVal()方法会把参数的变量转换成节点，计算Hash值之后加入到散列桶里，根据桶里已有元素的类型，执行相应的插入逻辑。当链表长度超过8或者数组长度达到64，则会把链表转换成RBTree.</p><h5 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap:"></a>ConcurrentHashMap:</h5><p>底层也是通过数组+链表的方法实现，Key与Value都不允许为null</p><p>通过把整个Map拆分成N个Segment，使用了分段锁技术，对每一段数据分配一个锁，使得当一个锁被一个线程占有时，其他段的数据也能被访问，从而提高性能。</p><p>Segment基本上和HashMap一样。</p><h5 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap:"></a>ConcurrentSkipListMap:</h5><h5 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap:"></a>LinkedHashMap:</h5><h5 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap:"></a>WeakHashMap:</h5><h5 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap:"></a>EnumMap:</h5><h5 id="SortedMap"><a href="#SortedMap" class="headerlink" title="SortedMap:"></a>SortedMap:</h5><h5 id="IdentityHashMap"><a href="#IdentityHashMap" class="headerlink" title="IdentityHashMap:"></a>IdentityHashMap:</h5><h5 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap:"></a>TreeMap:</h5><h4 id="两个特殊的结构"><a href="#两个特殊的结构" class="headerlink" title="两个特殊的结构:"></a>两个特殊的结构:</h4><h5 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable:"></a>Hashtable:</h5><p>底层实现是数组+链表，无论Key还是Value都不允许为null.保持线程安全的方式是锁住整个HashTable，效率较低。</p><h5 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque:"></a>ArrayDeque:</h5><hr><div class="post-announce">感谢您的阅读，本文由 <a href="http://ALEGANT.github.io">Alegant's技术博客</a> 版权所有。如若转载，请注明出处：Alegant's技术博客（<a href="http://ALEGANT.github.io/2020/04/09/JavaBase/">http://ALEGANT.github.io/2020/04/09/JavaBase/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/2020/04/08/HelloWorld/" title="Hello World"><i class="iconfont icon-prev"></i>Hello World</a></div><div class="post__prev post__prev--right"><a href="/2020/04/17/bioModel/" title="Netty Frame">Netty Frame<i class="iconfont icon-next"></i></a></div></div></div></article></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">简介</h3><p class="block__text">学习记录和兴趣交流的博客</p></div><div class="sidebar__block"><h3 class="block__title">文章分类</h3></div><div class="sidebar__block"><h3 class="block__title">最新文章</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2020/04/17/bioModel/" title="Netty Frame"><div class="item__cover"><img src="img/Netty.jpg" alt="Netty Frame"></div><div class="item__info"><h3 class="item__title">Netty Frame</h3><span class="item__text">2020-04-17</span></div></a></li><li class="latest-post-item"><a href="/2020/04/09/JavaBase/" title="Java基础"><div class="item__cover"><img src="img/Javabase.jpg" alt="Java基础"></div><div class="item__info"><h3 class="item__title">Java基础</h3><span class="item__text">2020-04-09</span></div></a></li><li class="latest-post-item"><a href="/2020/04/08/HelloWorld/" title="Hello World"><div class="item__cover"><img src="img/helloworld.jpg" alt="Hello World"></div><div class="item__info"><h3 class="item__title">Hello World</h3><span class="item__text">2020-04-08</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">文章标签</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/BIO/">BIO</a></li><li class="tag-item"><a class="tag-link" href="/tags/Java/">Java</a></li><li class="tag-item"><a class="tag-link" href="/tags/NIO/">NIO</a></li><li class="tag-item"><a class="tag-link" href="/tags/Netty/">Netty</a></li><li class="tag-item"><a class="tag-link" href="/tags/helloWorld/">helloWorld</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E5%9F%BA%E7%A1%80/">基础</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E7%AE%80%E4%BB%8B/">简介</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E9%9B%86%E5%90%88/">集合</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">关于</h3><div class="item__content"><p class="item__text">本站是基于 Hexo 搭建的静态资源博客，主要用于分享日常学习、生活及工作的一些心得总结。</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>SHENZHEN, Guangdong Province, China</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>736065863@qq.com</span></li></ul></div></div><div class="footer-top__item footer__image"><img src="/img/avatar.png" alt="logo" title="Alegant's技术博客"></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">CopyRight © made by <a href="https://github.com/ALEGANT" target="_blank">ALEGANT</a>, ©theme <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2017 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, made by <a href="https://github.com/Mrminfive" target="_blank">minfive</a>.</p><ul class="footer__social-network clearfix"><li class="social-network__item"><a href="https://github.com/ALEGANT" target="_blank" title="github"><i class="iconfont icon-github"></i></a></li><li class="social-network__item"><a href="mailto:736065863@qq.com" target="_blank" title="email"><i class="iconfont icon-email"></i></a></li></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>