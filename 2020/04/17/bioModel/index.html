<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><title>Netty Frame | 桃李无言，下自成蹊</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="[object Object]"><meta name="designer" content="minfive"><meta name="keywords" content="ALEGANT,Java,服务端"><meta name="description" content="学习记录和兴趣交流的博客"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><link rel="canonical" href="http://alegant.github.io/2020/04/17/bioModel/index.html"><link rel="icon" type="image/png" href="/img/favicon.ico" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="Alegant's技术博客"><link rel="stylesheet" href="/scss/views/page/post.css"><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Alegant's技术博客" type="application/atom+xml"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(/img/loader.gif)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="Alegant's技术博客" alt="Alegant's技术博客"><img src="/img/logo.png" alt="Alegant's技术博客"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="首页" title="首页">首页</a></li><li class="nav__item"><a href="/archives" alt="归档" title="归档">归档</a></li><li class="nav__item"><a href="/about" alt="关于" title="关于">关于</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="img/Netty.jpg" alt="Netty Frame"></div><header class="post__info"><h1 class="post__title">Netty Frame</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="https://www.github.com/ALEGANT" target="_blank" rel="noopener">ALEGANT</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2020-04-17</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/Netty/">Netty</a></li><li class="mark__item"><a href="/tags/BIO/">BIO</a></li><li class="mark__item"><a href="/tags/NIO/">NIO</a></li></ul></div></div></header><div class="post__content"><h1 id="Netty框架的发展及其基础"><a href="#Netty框架的发展及其基础" class="headerlink" title="Netty框架的发展及其基础"></a>Netty框架的发展及其基础</h1><p>“Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients.”</p><p>官网对于Netty框架的定义:”一个异步的基于事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络IO程序”</p><p>Netty本质是一个NIO框架。</p><h2 id="BIO模型"><a href="#BIO模型" class="headerlink" title="BIO模型"></a>BIO模型</h2><h3 id="什么是BIO模型"><a href="#什么是BIO模型" class="headerlink" title="什么是BIO模型"></a>什么是BIO模型</h3><p>BIO是Java传统io，相关类与接口在java.io包下，BIO是同步阻塞IO，服务器为每个连接创立一个线程，如果线程不做任何事将会造成不必要的系统开销，在jdk1.4之前只有BIO可以使用，可以通过使用线程池机制进行改善从而连接多个客户端。</p><p>BIO适用于连接数目小且固定的框架，对服务器资源要求比较高。</p><h3 id="BIO流程"><a href="#BIO流程" class="headerlink" title="BIO流程"></a>BIO流程</h3><p><img src="/2020/04%5C17%5CNettyFrame%5Cimg%5CBIOmodle.png" alt="BIOModle"></p><ol><li>服务器启动ServerSocket</li><li>客户端启动Socket对服务器进行通信，默认情况下服务器对每个连接创建一个线程</li><li>客户端发出请求后，等待服务器的线程响应，如果没有则继续等待(至超时)或者被拒绝，如果有相应，则等待请求结束后(回调完成)再继续执行。</li></ol><h3 id="BIO-demo"><a href="#BIO-demo" class="headerlink" title="BIO demo"></a>BIO demo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		</span><br><span class="line"><span class="comment">//		ExecutorService threadPool = Executors.newCachedThreadPool();</span></span><br><span class="line">		<span class="comment">// 服务器创建ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"Server on!"</span>);</span><br><span class="line">            <span class="comment">// 循环等待连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">final</span> Socket socket = serverSocket.accept();</span><br><span class="line">			System.out.println(<span class="string">"Client connect successful"</span>);</span><br><span class="line"><span class="comment">//	        线程池优化代码    </span></span><br><span class="line"><span class="comment">//			threadPool.execute(new Runnable() &#123;</span></span><br><span class="line"><span class="comment">//				public void run() &#123;</span></span><br><span class="line"><span class="comment">//					handler(socket);</span></span><br><span class="line"><span class="comment">//				&#125;</span></span><br><span class="line"><span class="comment">//			&#125;);</span></span><br><span class="line">			<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					handler(socket);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;.run();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"ThreadId:"</span> + Thread.currentThread().getId());</span><br><span class="line">			<span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">			InputStream input = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span>(;;)&#123;</span><br><span class="line">				<span class="keyword">int</span> read = input.read(bytes);</span><br><span class="line">				<span class="keyword">if</span> (read != -<span class="number">1</span>) &#123;</span><br><span class="line">					System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,read));</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				socket.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码注释掉的部分是使用线程池优化的代码，我们可以使用telnet的send命令给服务器发送数据，当我们连接多个命令行时，可以看到线程的id不一致，说明BIO是创建了多个线程去实现IO</p><h2 id="NIO模型"><a href="#NIO模型" class="headerlink" title="NIO模型"></a>NIO模型</h2><h3 id="什么是NIO模型"><a href="#什么是NIO模型" class="headerlink" title="什么是NIO模型"></a>什么是NIO模型</h3><p>Java NIO 全程Java non-Blocking IO，从Jdk1.4之后开始支持，是同步非阻塞的io模型，相关的类与接口定义在Java.nio包下，包里面对Java.IO包下的很多类进行改写，由Channel(管道)、Buffer(缓冲区)、Selector(选择器)三个核心部分组成，是面向缓冲区编程的，数据读取到缓冲区，需要时可在缓冲区中前后移动，增加了处理过程中的灵活性，从而提供非阻塞的高伸缩性网络。</p><p>当线程从通道中获得请求或者获取到数据时，线程会做出相应的处理，当没有数据时线程则可以去处理其它管道而不会导致线程阻塞。一个线程输入一些数据到达管道，但不需要等待它完全写入，这时线程同时可以去做别的事情。</p><h4 id="部件关系"><a href="#部件关系" class="headerlink" title="部件关系:"></a>部件关系:</h4><p>Channel与Buffer一一对应，一个Selector对应一个线程，一个Selector对应多个Channel。Channel需要到对应的Selector中注册，Selector会处理哪个Channel是由事件(event)决定的。Buffer是一个内存块，底层是一个数组，除了boolean类型，其它基本类型都支持。Buffer需要通过filp()方法改变读写模式。</p><p>常用的Channel类有FileChannel(文件管道，传输文件)、ServerSocketChannel(服务器套接字管道，TCP数据传输)、SocketChannel(套接字管道，TCP数据传输)、DatagramChannel(数据包管道，UDP数据传输)</p><p>Channel:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		String str = <span class="string">"Hello os"</span>;</span><br><span class="line">		<span class="comment">// 创建文件输出流</span></span><br><span class="line">		FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"E:\\test.txt"</span>);</span><br><span class="line">		<span class="comment">// 获取输出流相应的管道</span></span><br><span class="line">		FileChannel fileChannel = fileOutputStream.getChannel();</span><br><span class="line">		<span class="comment">// 创建btye类型缓冲区</span></span><br><span class="line">		ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">		<span class="comment">// 把字符串转换成byte格式放入缓冲区</span></span><br><span class="line">		buffer.put(str.getBytes());</span><br><span class="line">		<span class="comment">// 改变缓冲区的状态(将position置1)</span></span><br><span class="line">		buffer.flip();</span><br><span class="line">		<span class="comment">// 讲缓冲区写入管道</span></span><br><span class="line">		fileChannel.write(buffer);</span><br><span class="line">		<span class="comment">// 关闭管道</span></span><br><span class="line">		fileOutputStream.close();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p>以上是一个利用管道和缓冲区将字符串写入文件的demo，方便与理解管道和缓冲区的关系。</p><p>Selector:</p><h3 id="NIO流程"><a href="#NIO流程" class="headerlink" title="NIO流程"></a>NIO流程</h3><p><img src="/2020/04%5C17%5CNettyFrame%5Cimg%5CBIOmodle.png" alt="BIOModle"></p><ol><li><p>服务器创建ServerSocketChannel来，绑定好连接的地址</p></li><li><p>创建Selector，并把ServerSocketChannel注册到Selector，设置事件，ServerSocketChannel是用于处理连接事件，注册时设置ops变量为SelectionKey.OP_ACCEPT。</p></li><li><p>服务器循环等待，直到客户端连接时，可以通过Selector.selectedKeys()方法获得触发了事件的SelectionKey的集合</p></li><li><p>当触发的事件是accept事件，我们使用serverSocketChannel的accept()方法，去为客户端生成相应的socketChannel</p></li><li><p>将socketChannel注册(register(Selector selector,int ops))到Selector上，注册后返回一个SelectionKey与该Selector关联</p></li><li><p>Selector进行监听select方法，返回发生了关心的事件的通道个数，使用selectedKeys()方法获得需要处理的SelectionKey，通过SelectionKey的channel()方法，获得SocketChannel，从而完成业务逻辑。</p><p>小结:Selector是面向Channel工作的，对于连接事件会专门用serverSocketChannel来处理，而对于客户端的数据交互则会用socketChannel来处理。初学的时候名字容易搞乱。</p></li></ol><h3 id="NIO相对于BIO做了什么优化"><a href="#NIO相对于BIO做了什么优化" class="headerlink" title="NIO相对于BIO做了什么优化"></a>NIO相对于BIO做了什么优化</h3><p>BIO是以流的方式处理数据，而NIO是以块的方式处理数据，效率高很多。</p><p>BIO基于字节流和字符流操作，而NIO基于Channel和Buffer进行操作，数据和缓冲区可以互相读取，Selector监听管道事件从而使得单个线程监听多个客户端的管道。</p><h3 id="NIO-demo"><a href="#NIO-demo" class="headerlink" title="NIO demo"></a>NIO demo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 创建ServerSocket管道</span></span><br><span class="line">		ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">		<span class="comment">// 管道绑定端口</span></span><br><span class="line">		serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">		<span class="comment">// 设置管道非阻塞</span></span><br><span class="line">		serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">		<span class="comment">// 创建选择器</span></span><br><span class="line">		Selector selector = Selector.open();</span><br><span class="line">		<span class="comment">// 把管道注册到选择器上</span></span><br><span class="line">		serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">		<span class="comment">// 循环等待连接事件</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">// 等一秒连接事件</span></span><br><span class="line">			<span class="keyword">if</span> (selector.select(<span class="number">1000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">				System.out.println(<span class="string">"服务器等待1秒无连接"</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 就获取selectionKey集合</span></span><br><span class="line">			Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">			<span class="comment">// 通过selectionKeys获得通道</span></span><br><span class="line">			Iterator&lt;SelectionKey&gt; selectionIterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (selectionIterator.hasNext()) &#123;</span><br><span class="line">				SelectionKey key = selectionIterator.next();</span><br><span class="line">				<span class="comment">// 对于连接请求</span></span><br><span class="line">                <span class="comment">// ==================分割线=======================</span></span><br><span class="line">				<span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">					<span class="comment">// 如果是连接请求，则给它生成一个管道</span></span><br><span class="line">					SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">					<span class="comment">// 设置管道非阻塞</span></span><br><span class="line">					socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">					<span class="comment">// 并把这个管道的读事件注册到选择器上</span></span><br><span class="line">					socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 对于读区事件</span></span><br><span class="line">				<span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">					<span class="comment">// 获得key所对应的channel</span></span><br><span class="line">					SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">					<span class="comment">// 获得key所对应的buffer</span></span><br><span class="line">					ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">					<span class="comment">// 把chennel读取到的数据存入buffer中</span></span><br><span class="line">					channel.read(buffer);</span><br><span class="line">					System.out.println(<span class="string">"从客户端 获得"</span> + <span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">				&#125;</span><br><span class="line">                <span class="comment">// ===================分割线=====================</span></span><br><span class="line">				selectionIterator.remove();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 创建socketChannel</span></span><br><span class="line">		SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">		<span class="comment">// 设置非阻塞</span></span><br><span class="line">		socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">		<span class="comment">// 设置连接地址</span></span><br><span class="line">		InetSocketAddress inetSoccketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>,<span class="number">8080</span>);</span><br><span class="line">		<span class="comment">// 连接服务器</span></span><br><span class="line">		<span class="keyword">if</span>(!socketChannel.connect(inetSoccketAddress)) &#123;</span><br><span class="line">			<span class="keyword">while</span>(!socketChannel.finishConnect()) &#123;</span><br><span class="line">				System.out.println(<span class="string">"连接未完成，客户端继续其他工作"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		String str = <span class="string">"Hello?Can you hear me?"</span>;</span><br><span class="line">		<span class="comment">// 将字符串放入缓冲区</span></span><br><span class="line">		ByteBuffer buffer = ByteBuffer.wrap(str.getBytes());</span><br><span class="line">		<span class="comment">// 写入管道</span></span><br><span class="line">		socketChannel.write(buffer);</span><br><span class="line">		System.in.read();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码展示了一个简单的NIO服务器和客户端，讲述了NIO框架的部件之间的关系，尽管与BIO相比进行了优化但是仍然拥有许多问题：</p><ol><li>NIO的类库比较复杂，需要熟练掌握才能使用，</li><li>涉及到Reactor模式和多线程操作，对基础要求比较高</li><li>开发难度大，需要面对的问题比较多如客户端断线重连、网络闪断、半包读写、失败缓存、网络拥塞、异常流处理等问题</li><li>本身有Bug，如Epoll Bug，导致Selector空轮询，导致CPU占用率100%，直到jdk1.7问题仍然存在。(直到jdk 6u4才解决)</li></ol><h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><h3 id="了解Netty框架前需要的准备"><a href="#了解Netty框架前需要的准备" class="headerlink" title="了解Netty框架前需要的准备"></a>了解Netty框架前需要的准备</h3><h4 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式:"></a>Reactor模式:</h4><h5 id="Reactor模式-又称dispather模式-有两个核心组成部件"><a href="#Reactor模式-又称dispather模式-有两个核心组成部件" class="headerlink" title="Reactor模式(又称dispather模式)有两个核心组成部件:"></a>Reactor模式(又称dispather模式)有两个核心组成部件:</h5><ol><li>Reactor:(分配器)负责监听与分发事件，分发给适当的处理程序来对IO事件做出反应，可以通过Provider获得.</li><li>Handlers:(处理器)负责处理I/O事件要完成的实际事件</li></ol><h5 id="Reactor模式的构成"><a href="#Reactor模式的构成" class="headerlink" title="Reactor模式的构成:"></a>Reactor模式的构成:</h5><ol><li>Handle(句柄或是描述符):本质上是一种资源，有操作系统提供；该资源用于表示一个个的事件，比如说文件描述符，或是针对网络编程中的Socket描述符。是事件产生的发源地。</li><li>Synchronous Event Demultiplexer(同步事件分离器):本身是一个系统调用，用于等待事件的发生。调用方在调用它的时候会被阻塞，直到同步事件分离器上有事件为止。对应NIO组件里面的Selector；对应的阻塞方法是select()方法。</li><li>Event Handler(事件处理器):本身由多个回调方法构成，回调方法构成了与应用相关的对于某个时间的反馈机制。</li><li>Concrete Event Handler(具体事件处理器):是事件处理其的实现，本身实现了事件处理其所提供的各种回调方法，从而实现特定与业务的逻辑。</li><li>Initiation Dispatcher(初始分发器):实际上就是Selector。</li></ol><p>在NIO里面没有提供关于事件处理器和具体事件处理器的接口。</p><h5 id="分类"><a href="#分类" class="headerlink" title="分类:"></a>分类:</h5><h6 id="单Reactor单线程"><a href="#单Reactor单线程" class="headerlink" title="单Reactor单线程:"></a>单Reactor单线程:</h6><p>NIO的demo所使用模式就是单Reactor单线程的模式，其中Selector就担任着Reactor的角色，而在=号分割线中间的代码就是具体的handler(只是没有抽出来做成handler)。适合用在客户端数量有限，处理快的场景。</p><p>问题:</p><p>性能上:当并发量比较高的时候这种模型就会产生阻塞的问题，且无法发挥多核CPU的性能，Handler处理某个连接业务时会导致进程无法处理其它连接事件，导致性能瓶颈.</p><p>可靠性上:如果线程意外终止或者死循环，会导致整个系统通信模块不可用，不能接收或者处理外部信息造成节点故障。</p><h6 id="单Reactor多线程"><a href="#单Reactor多线程" class="headerlink" title="单Reactor多线程:"></a>单Reactor多线程:</h6><p><img src="/2020/04%5C17%5CNettyFrame%5Cimg%5ConeReactormoreThread.png" alt="BIOModle"></p><p>流程:</p><ol><li>Reactor对象通过select监控客户端请求事件，收到事件之后进行分发</li><li>如果是建立连接的请求，则通过处理连接请求并创建Handler处理完成连接后的各种事件(accept方法生成管道注册到选择器这一系列操作)，</li><li>如果不是连接请求，则由eeactor分发调用连接相应的handler来处理</li><li>handler只处理响应时间，不处理具体业务逻辑，荣国read读取数据后，会分发给后面的worker线程池处理某个线程处理业务</li><li>worker线程池分配独立线程完成真正的业务，并将结果返回给handler。</li><li>handler收到响应之后，通过send将结果返回给client</li></ol><p>好处:可以充分利用多核CPU的能力</p><p>问题:多线程数据共享和访问比较复杂，不好维护，reactor处理所有的事件的监听与响应，在单线程运行，在高并发场景容易出现性能瓶颈(性能瓶颈出现在主线程的handler上，压力依然比较大)。</p><h6 id="主从Reactor多线程"><a href="#主从Reactor多线程" class="headerlink" title="主从Reactor多线程:"></a>主从Reactor多线程:</h6><p>Netty所使用的Reactor模式就是主从Reactor多 线程模式.</p><p>工作原理:</p><p>对于单Reactor多线程模型中，Reactor在单线程中运行，高并发场景下容易成为性能瓶颈，可以让Reactor在多线程中运行(谁压力大，就把谁扔到多线程里面处理)。</p><p>流程:</p><ol><li>Reactor主线程MainReactor对象通过select监听连接事件，都到事件后处理连接事件。(这点跟前面两个都一样)</li><li>处理连接事件后，MainReactor将连接分配给subReactor</li><li>subreactor将连接加入到连接队列进行监听，并创建handler进行各种事件处理</li><li>当有新事件发生时，subreactor就会调用对应的handler进行处理</li><li>handler通过read读取数据，分发给后面的worker线程处理，worker线程池分配独立的worker线程进行业务处理，并返回结果给handler。</li><li>handler收到结果后，用send将结果返回给client.</li></ol><p><img src="/2020/04%5C17%5CNettyFrame%5Cimg%5CmasterBackupReactor.png" alt="BIOModle"></p><h5 id="简单总结区分"><a href="#简单总结区分" class="headerlink" title="简单总结区分"></a>简单总结区分</h5><p>单Reactor多线程相对于单Reactor单线程而言，把handler部分使用线程池机制实现了多路复用从而提高了性能，但是由于handler都挤在一个线程，当吞吐量较大的时候会有性能瓶颈；</p><p>主从Reactor多线程相对于单Reactor多线程增加了一个层Reactor，用于专门处理读写事件，当吞吐量较大的时候可以多用几个Reactor来分担吞吐量，从而解决性能瓶颈问题，再往下层也使用了线程池来多路复用。</p><h5 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h5><p>这个模式本身不依赖于业务逻辑，在编程中广泛使用如:Netty框架、Nginx和Memcached等</p><h4 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h4><h3 id="Netty框架详解"><a href="#Netty框架详解" class="headerlink" title="Netty框架详解"></a>Netty框架详解</h3><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><p><img src="/2020/04%5C17%5CNettyFrame%5Cimg%5CNettyFrame.jpg" alt="BIOModle"></p><p>Netty抽象出两组线程池，BossGroup专门负责处理接受客户端的连接，WorkerGroup专门负责处理网络读写。</p><p>两个线程池都是NioEventLoopGroup</p><p>NioEventLoopGroup相当于一个事件循环组，组中包含多个事件循环(NioEventLoop)。</p><p>NioEventLoop表示一个不断循环的执行处理任务的线程，每个NioEventLoop都有一个selector，用于监听绑定在其身上的socket的网络通讯。</p><p>BossNioEventLoop执行的步骤有三步:轮询；处理连接请求，获取连接对应的通道(NioSocketChannel)，将通道注册到Worker的Selector上；处理任务队列的任务(即处理队列的所有连接任务)。</p><p>WorkerNIOEventLoop执行步骤：轮询读写事件；处理事件，在对应的NioSockerChannel处理，处理任务队列的任务(即处理队列的所有读写任务)。</p><h4 id="TCP通讯demo"><a href="#TCP通讯demo" class="headerlink" title="TCP通讯demo"></a>TCP通讯demo</h4><h5 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码:"></a>服务端代码:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">nettyServer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 创建两个线程组</span></span><br><span class="line"><span class="comment">		 * 其中bossGroup负责连接 workerGroup负责读写</span></span><br><span class="line"><span class="comment">		 * 两个都是循环等待</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">		EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 设置启动服务器对象</span></span><br><span class="line">			ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">			<span class="comment">//配置启动参数,链式编程</span></span><br><span class="line">			serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">			<span class="comment">// 设置通道类型</span></span><br><span class="line">			.channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">			// 设置线程队列得到连接个数(设置<span class="title">bossGroup</span>的<span class="title">Channel</span>属性)</span></span><br><span class="line"><span class="class">			.<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>, 128)</span></span><br><span class="line"><span class="class">			// 设置保持活动链接状态</span></span><br><span class="line"><span class="class">			.<span class="title">childOption</span>(<span class="title">ChannelOption</span>.<span class="title">SO_KEEPALIVE</span>, <span class="title">true</span>)</span></span><br><span class="line"><span class="class">			// 创建<span class="title">workerGroup</span>通道处理器</span></span><br><span class="line"><span class="class">			.<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">					<span class="comment">// 处理器具体设置</span></span><br><span class="line">					ch.pipeline().addLast(<span class="keyword">new</span> nettyServerHandler());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">			System.out.println(<span class="string">"I'm Server,I'm ready"</span>);</span><br><span class="line">			<span class="comment">// ChannelFuture是绑定成功后的回调对象，包含通道的各种信息</span></span><br><span class="line">			ChannelFuture cf = serverBootstrap.bind(<span class="number">8080</span>).sync();</span><br><span class="line">			<span class="comment">// 对关闭通道进行监听</span></span><br><span class="line">			cf.channel().closeFuture().sync();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			bossGroup.shutdownGracefully();</span><br><span class="line">			workerGroup.shutdownGracefully();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="服务端处理器代码"><a href="#服务端处理器代码" class="headerlink" title="服务端处理器代码:"></a>服务端处理器代码:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义的Handler需要继承Netty所规定好的某个HandlerAdapter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ALEGANT</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">nettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 读取事件时对数据的操作</span></span><br><span class="line"><span class="comment">	 * ctx包含上下文信息，包含pipeline和channel以及地址</span></span><br><span class="line"><span class="comment">	 * msg客户端数据</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"ctx = "</span> + ctx);</span><br><span class="line">		ByteBuf buffer = (ByteBuf)msg;</span><br><span class="line">		System.out.println(<span class="string">"From "</span> + ctx.channel().remoteAddress() + <span class="string">" get msg : "</span> + buffer.toString(CharsetUtil.UTF_8));</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 	读取数据完毕时对数据的操作</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">"Get it,thank you"</span>,CharsetUtil.UTF_8));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 发生异常后的处理 </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ctx.close();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码:"></a>客户端代码:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">nettyClient</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 事件循环组</span></span><br><span class="line">		EventLoopGroup clientGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 与服务端不同的是 客户端创建的是Bootstrap而不是ServerBootstrap</span></span><br><span class="line">			Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">			<span class="comment">// 设置启动参数</span></span><br><span class="line">			bootstrap.group(clientGroup)</span><br><span class="line">			<span class="comment">// 设置通道的实现类型 注意 服务端的是NioServerSocketChannel 多了个Server</span></span><br><span class="line">			.channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">			// 设置管道处理器</span></span><br><span class="line"><span class="class">			.<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">				<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">					<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">					ch.pipeline().addLast(<span class="keyword">new</span> nettyClientHandler());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">			System.out.println(<span class="string">"I'm Client,I'm ready!"</span>);</span><br><span class="line">			<span class="comment">// 连接服务端 关于ChannelFuture后面会继续讲解</span></span><br><span class="line">			ChannelFuture cf = bootstrap.connect(<span class="string">"127.0.0.1"</span>, <span class="number">8080</span>).sync();</span><br><span class="line">			<span class="comment">// 对关闭管道事件进行监听</span></span><br><span class="line">			cf.channel().close().sync();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			clientGroup.shutdownGracefully();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="客户端处理器"><a href="#客户端处理器" class="headerlink" title="客户端处理器:"></a>客户端处理器:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">nettyClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 数据到达时触发方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Client:"</span> + ctx);</span><br><span class="line">		ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">"hello,Server"</span>,CharsetUtil.UTF_8));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 抛出异常时触发的方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		cause.printStackTrace();</span><br><span class="line">		ctx.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 读取事件时触发的方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ByteBuf buf = (ByteBuf)msg;</span><br><span class="line">		System.out.println(<span class="string">"Message From Server :"</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">		System.out.println(<span class="string">"Server Address:"</span> + ctx.channel().remoteAddress());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个demo实现了最简单的使用Netty框架实现TCP通信，但是这么写还存在很多问题，例如粘包拆包、POJO的定义等等，而且如果对Netty没有了解的人会不清楚整个启动的流程以及一些Netty写好的类的功能及其意义，下面将一个一个点逐个击破。</p><h4 id="一些概念的补充"><a href="#一些概念的补充" class="headerlink" title="一些概念的补充:"></a>一些概念的补充:</h4><p>一开始讲过”Netty是一个异步的基于事件驱动的网络应用框架”，这里面有个异步的关键词还没有讲解，事件驱动通过前面的BIO/NIO等模型应该已经有个清楚的认知，就是发生了某件事之后去驱动另一个部件去做点什么。同样的，在Handler里面也是，把读写过程进行了拆分，并对读写过程的各个阶段进行包装。同时，还增加了回调对象(ChannelFuture)，用于同步或者异步处理。假如有某个业务耗时特别长，那么本质上在等待的过程还是阻塞的，我们需要让它进行异步执行。</p><h5 id="异步模型和ChannelFuture"><a href="#异步模型和ChannelFuture" class="headerlink" title="异步模型和ChannelFuture"></a>异步模型和ChannelFuture</h5><p>异步模型和同步模型相对立，同步模型在调用之后需要等待调用结果，而异步模型则不能立刻获得结果，实际处理调用的组件在完成后，通过状态、通知和回调通知调用者。</p><p>Netty的异步模型是建立在future和callback之上的，callback就是回调。future则是用于监控方法的处理过程。(通过future可以监控方法的处理过程)。</p><p>Netty中的I/O操作是异步的，在Bind()、Write()、Connect()等操作会简单的返回一个ChannelFuture，用户可以通过它提供的方法主动获取或者可以添加监听器，监听相应的事件，获得IO操作结果。拦截操作和转换出入站数据只需要提供callBack或者使用future即可。此外，注意ChannelFuture是一个接口，一般来说真正的实现类是DefaultChannelPromise，这个类由执行器和Channel构造而成，由原生JDK的Future接口改进而来，可以通过get()方法获得结果，但是值得注意的是这个方法是阻塞的，会等待到有结果为止，这个特性会导致一个问题，开发者不知道什么时候去调用get()方法，如果早了就需要等待，晚了事件响应就不及时，同样的原声JDK的isDone()方法对异步任务的完成结果描述不清晰、调用不方便，为此Netty对这个接口增加了关于Listener的一系列方法(addListener、removeListener等)，来增加事件性，并且还提供了isSuccess()方法来更加清晰地描述事件地结果，使得事件发生了之后直接响应事件而不需要主动去调用，从而提高性能。</p><p>代码中还会有channelFuture的sync()方法。这个sync()方法字面上理解就是同步的意思，实际上这个方法就是使得对应的ChannelFuture会去等待相应的结果，直到得到回调才会继续执行后续的代码。在理解了这点之后再去看看nettyServer的第31行，在服务器绑定了8080端口后，服务器会获得一个绑定了相应NioServerSocketChannel的ChannelFuture，然后对这个future监听closeFuture()事件并等待回调。进入debug模式进行逐步调试会发现，代码卡在了第33行，当本地Socket关闭了就会获得相应的回调并执行后续的两个shutdownGracefully()来释放系统资源。</p><p>ChannelFuture常用操作:</p><table><thead><tr><th>方法名</th><th>方法作用</th></tr></thead><tbody><tr><td>isDone</td><td>判断是否完成(正常完成、用户取消、抛出异常等)</td></tr><tr><td>isSuccess</td><td>判断当前操作是否成功</td></tr><tr><td>getCause</td><td>获取当前操作失败原因</td></tr><tr><td>isCancelled</td><td>判断已成功的操作是否被取消</td></tr><tr><td>addListener</td><td>注册监听器，操作完成会通知指定监听器</td></tr></tbody></table><h5 id="bootstrap、ServerBootstrap"><a href="#bootstrap、ServerBootstrap" class="headerlink" title="bootstrap、ServerBootstrap"></a>bootstrap、ServerBootstrap</h5><p>bootstrap是启动引导，Netty程序通常由一个Bootstrap开始，主要作用是配置整个Netty程序，设置各个组件。</p><p>bootstrap是客户端启动引导类，ServerBootstrap是服务器启动引导类，这两个类都是继承AbstractBootstrap这个抽象类，在实现时，会根据前面的设置(group()、channel()、option()等方法设置的参数)进行初始化，在设置参数时参数被保存，ServerBootstrap在调用bind()方法的时候(bootStrap在调用connect()方法)的时候，相关的Channel和ChannelFuture才会被构造，在内部使用了工厂模式，调用了前面传入的参数，通过反射来创造Channel实例，然后再对各个选项通过键值对的方式进行设值，其中ChannelOption里面有常量池，里面通过泛型的方式定义类对应设置所需要的参数类型。生成了Channel之后就会调用相应的init方法去执行设置的逻辑，对Channel类型、Channel设置等进行设置，可以留意到我们的代码(NettyServer的第18行-22行)里面有option和childOption这两个东西，与之前对应的这两个分别设置分别对应bossGroup和workGroup，我们对childHandler进行了设置但是没有对handler进行设置，这是因为在底层的初始化方法里面会在管道的的末尾增加接收器。</p><p>常见方法:</p><table><thead><tr><th>方法名</th><th>方法参数</th><th>方法作用</th><th>备注</th></tr></thead><tbody><tr><td>group</td><td>EventGroup,EventGroup</td><td>设置两个事件循环</td><td>用于服务器端</td></tr><tr><td>channel</td><td>Class&lt;? extends C&gt; channelClass</td><td>用来设置服务器端的通道实现</td><td></td></tr><tr><td>option</td><td>ChannelOption<t>, T</t></td><td>为parentGroup对应的Channel增加设置</td><td>根据泛型不同，值的类型可以变更</td></tr><tr><td>childOption</td><td>ChannelOption<t>,T</t></td><td>为childGroup对应的Channel增加设置</td><td></td></tr><tr><td>childHandler</td><td>childHandler</td><td>设置业务处理类</td><td>自定义Handler</td></tr><tr><td>bind</td><td>int</td><td>用于服务端，占用端口号</td><td></td></tr><tr><td>connect</td><td>String,int</td><td>用于客户端，链接服务器</td><td></td></tr></tbody></table><h5 id="Channel、Pipeline、Handler、ChannelHandlerContext"><a href="#Channel、Pipeline、Handler、ChannelHandlerContext" class="headerlink" title="Channel、Pipeline、Handler、ChannelHandlerContext"></a>Channel、Pipeline、Handler、ChannelHandlerContext</h5><p>pipeline是一个存放自定义的ChannelHandlerContext的容器，其数据结构为双向链表，本身不处理事件，链表元素是ChannelHandlerContext，ChannelHandlerContext则像绑定了Channel、Handler、用户所定义的Handler的别名、pipeline、EventExecutor等信息，使得通过ChannelHandlerContext可以获得所有的相关信息。不但如此，我们也可以通过单个节点推导前后的节点(双向链表的特性)，handler会对进栈和出栈的事件进行拦截操作，这些Handler负责相应的Channel的所有I/O事件(I/O事件都能注册相应的Handler以方便在事件进行到各个阶段的时候可以让被注册的Handler进行处理)。</p><table><thead><tr><th>名字</th><th>作用</th></tr></thead><tbody><tr><td>NioSocketChannel</td><td>异步的客户端TCP Socket连接</td></tr><tr><td>NioServerSocketChannel</td><td>异步的服务器端TCP Socket连接</td></tr><tr><td>NioDatagramChannel</td><td>异步的UDP连接</td></tr><tr><td>NioSctpChannel</td><td>异步的客户端stcp连接</td></tr><tr><td>NioSctpServerChannel</td><td>异步的服务端stcp连接，涵盖UDP和TCP网络IO以及文件IO</td></tr></tbody></table><h5 id="EventLoopGroup以及EventLoop"><a href="#EventLoopGroup以及EventLoop" class="headerlink" title="EventLoopGroup以及EventLoop"></a>EventLoopGroup以及EventLoop</h5><p>EventLoopGroup是事件循环组，它是一个接口，它对原生JDK的线程池进行了封装与改进，负责存储事件循环(也就是线程)，底层就是一个死循环( for(;;){}或者while(ture){} )。构造方法里会默认设置CPU核数 * 2个事件循环，一般来说BossGroup用来负责处理连接事件，因此设置参数为1，使得循环组只有1个线程。EventLoopGroup接口里面有next()方法，使得可以在循环组中迭代地获得事件循环。在初始化的时候，会设置监听器，并在事件初始化完成的时候设置回调。</p><h6 id="与其他组建的对应关系"><a href="#与其他组建的对应关系" class="headerlink" title="与其他组建的对应关系"></a>与其他组建的对应关系</h6><p>一个EventLoopGroup拥有一个或多个EventLoop</p><p>EventLoop在整个生命周期会与唯一一个线程绑定，并且它所处理的I/O事件都在这个线程上处理。</p><p>一个Channel只会注册在一个EventLoop上，一个EventLoop可以处理一个或多个Channel。</p><h6 id="推论"><a href="#推论" class="headerlink" title="推论:"></a>推论:</h6><p>因此可以将Channel的引用进行缓存，可以确定，在对一个Channel进行操作时，即使在多线程环境下也是线程安全的，因为所操作的channel是绑定在一个EventLoop中，而EventLoop与唯一的一个线程绑定，因此对这个channel的操作都是在这个线程里面，不会出现多线程的问题，并且消息会按照顺序进行发送。(即Channel与线程绑定，对这个Channel的操作是在同个线程里面，不会出现多线程的问题。)</p><p>同时在实际业务开发过程里，不要讲耗时长的任务放入EventLoop的执行队列当中，因为它会阻塞其它的Channel的IO，为此需要一个业务线程池，将实际的业务操作放入专门的业务线程池。</p><p>常用的处理方式:</p><ol><li>在ChannelHandler的回调方法里面使用自定义的业务线程池</li><li>使用Netty提供的addLast(EventExecutorGroup group, ChannelHandler… handlers)方法(方法位于ChannelInitializer的initChannel方法获得pipeline，调用pipeline拥有此方法)，把具体任务放入业务线程池。(注意:对应的回调方法会在对应的Handler所在的线程组里面执行。)</li></ol><h4 id="粘包拆包以及编码解码"><a href="#粘包拆包以及编码解码" class="headerlink" title="粘包拆包以及编码解码"></a>粘包拆包以及编码解码</h4><p>Netty使用的模式是Reactor模式，而Reactor模式是面向块编程，当Selector获取到事件之后，去读取缓存区的数据，如果在短时间内缓存区的数据没有被读取(在一个读取间隔，同个Channel接收到多次数据)，那么这时候如果不做处理，框架将会出现粘包的问题，因此我们需要对数据进行处理，防止这个问题的出现。</p><p>对于这个问题，Netty在内部使用了internal包下的TypeParameterMatcher以确保传入参数类型的正确性，并检查类型，对于一般的业务逻辑，我们可以使用ObjectEncoder来实现POJO类的编码，也可以自己编写编码器和解码器，自需要继承ByteToMessageDecoder类并重写相应的Decode方法(MessageToByteEncoder重写Encode方法)，就可以编写与自身业务逻辑相应的编解码器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SquareDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx,ByteBuf in, List&lt;Object&gt; out)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">throws</span> Exception &#123;</span><br><span class="line">			out.add(in.readBytes(in.readableBytes()));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是ByteToMessageDecoder源码中的Demo，in就是缓存区的内容，out是存放解码的结果的容器，解码成功后在相应的handler可以获得对应的POJO。</p><div class="post-announce">感谢您的阅读，本文由 <a href="http://ALEGANT.github.io">Alegant's技术博客</a> 版权所有。如若转载，请注明出处：Alegant's技术博客（<a href="http://ALEGANT.github.io/2020/04/17/bioModel/">http://ALEGANT.github.io/2020/04/17/bioModel/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/2020/04/09/JavaBase/" title="Java基础"><i class="iconfont icon-prev"></i>Java基础</a></div><div class="post__prev post__prev--right"></div></div></div></article></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">简介</h3><p class="block__text">学习记录和兴趣交流的博客</p></div><div class="sidebar__block"><h3 class="block__title">文章分类</h3></div><div class="sidebar__block"><h3 class="block__title">最新文章</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2020/04/17/bioModel/" title="Netty Frame"><div class="item__cover"><img src="img/Netty.jpg" alt="Netty Frame"></div><div class="item__info"><h3 class="item__title">Netty Frame</h3><span class="item__text">2020-04-17</span></div></a></li><li class="latest-post-item"><a href="/2020/04/09/JavaBase/" title="Java基础"><div class="item__cover"><img src="img/Javabase.jpg" alt="Java基础"></div><div class="item__info"><h3 class="item__title">Java基础</h3><span class="item__text">2020-04-09</span></div></a></li><li class="latest-post-item"><a href="/2020/04/08/HelloWorld/" title="Hello World"><div class="item__cover"><img src="img/helloworld.jpg" alt="Hello World"></div><div class="item__info"><h3 class="item__title">Hello World</h3><span class="item__text">2020-04-08</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">文章标签</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/BIO/">BIO</a></li><li class="tag-item"><a class="tag-link" href="/tags/Java/">Java</a></li><li class="tag-item"><a class="tag-link" href="/tags/NIO/">NIO</a></li><li class="tag-item"><a class="tag-link" href="/tags/Netty/">Netty</a></li><li class="tag-item"><a class="tag-link" href="/tags/helloWorld/">helloWorld</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E5%9F%BA%E7%A1%80/">基础</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E7%AE%80%E4%BB%8B/">简介</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E9%9B%86%E5%90%88/">集合</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">关于</h3><div class="item__content"><p class="item__text">本站是基于 Hexo 搭建的静态资源博客，主要用于分享日常学习、生活及工作的一些心得总结。</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>SHENZHEN, Guangdong Province, China</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>736065863@qq.com</span></li></ul></div></div><div class="footer-top__item footer__image"><img src="/img/avatar.png" alt="logo" title="Alegant's技术博客"></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">CopyRight © made by <a href="https://github.com/ALEGANT" target="_blank">ALEGANT</a>, ©theme <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2017 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, made by <a href="https://github.com/Mrminfive" target="_blank">minfive</a>.</p><ul class="footer__social-network clearfix"><li class="social-network__item"><a href="https://github.com/ALEGANT" target="_blank" title="github"><i class="iconfont icon-github"></i></a></li><li class="social-network__item"><a href="mailto:736065863@qq.com" target="_blank" title="email"><i class="iconfont icon-email"></i></a></li></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>