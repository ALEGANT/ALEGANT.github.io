<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Alegant&#39;s技术博客</title>
  
  <subtitle>桃李无言，下自成蹊</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://alegant.github.io/"/>
  <updated>2020-05-09T15:44:28.508Z</updated>
  <id>http://alegant.github.io/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Netty Frame</title>
    <link href="http://alegant.github.io/2020/04/17/bioModel/"/>
    <id>http://alegant.github.io/2020/04/17/bioModel/</id>
    <published>2020-04-17T02:50:00.000Z</published>
    <updated>2020-05-09T15:44:28.508Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty框架的发展及其基础"><a href="#Netty框架的发展及其基础" class="headerlink" title="Netty框架的发展及其基础"></a>Netty框架的发展及其基础</h1><p>“Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients.”</p><p>官网对于Netty框架的定义:”一个异步的基于事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络IO程序”</p><p>Netty本质是一个NIO框架。</p><h2 id="BIO模型"><a href="#BIO模型" class="headerlink" title="BIO模型"></a>BIO模型</h2><h3 id="什么是BIO模型"><a href="#什么是BIO模型" class="headerlink" title="什么是BIO模型"></a>什么是BIO模型</h3><p>BIO是Java传统io，相关类与接口在java.io包下，BIO是同步阻塞IO，服务器为每个连接创立一个线程，如果线程不做任何事将会造成不必要的系统开销，在jdk1.4之前只有BIO可以使用，可以通过使用线程池机制进行改善从而连接多个客户端。</p><p>BIO适用于连接数目小且固定的框架，对服务器资源要求比较高。</p><h3 id="BIO流程"><a href="#BIO流程" class="headerlink" title="BIO流程"></a>BIO流程</h3><p><img src="/2020/04/17/bioModel/img/BIOmodle.png" alt="BIOModle"></p><ol><li>服务器启动ServerSocket</li><li>客户端启动Socket对服务器进行通信，默认情况下服务器对每个连接创建一个线程</li><li>客户端发出请求后，等待服务器的线程响应，如果没有则继续等待(至超时)或者被拒绝，如果有相应，则等待请求结束后(回调完成)再继续执行。</li></ol><h3 id="BIO-demo"><a href="#BIO-demo" class="headerlink" title="BIO demo"></a>BIO demo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ExecutorService threadPool = Executors.newCachedThreadPool();</span></span><br><span class="line"><span class="comment">// 服务器创建ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Server on!"</span>);</span><br><span class="line">            <span class="comment">// 循环等待连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">final</span> Socket socket = serverSocket.accept();</span><br><span class="line">System.out.println(<span class="string">"Client connect successful"</span>);</span><br><span class="line"><span class="comment">//        线程池优化代码    </span></span><br><span class="line"><span class="comment">//threadPool.execute(new Runnable() &#123;</span></span><br><span class="line"><span class="comment">//public void run() &#123;</span></span><br><span class="line"><span class="comment">//handler(socket);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;);</span></span><br><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">handler(socket);</span><br><span class="line">&#125;</span><br><span class="line">&#125;.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"ThreadId:"</span> + Thread.currentThread().getId());</span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">InputStream input = socket.getInputStream();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line"><span class="keyword">int</span> read = input.read(bytes);</span><br><span class="line"><span class="keyword">if</span> (read != -<span class="number">1</span>) &#123;</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,read));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">socket.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码注释掉的部分是使用线程池优化的代码，我们可以使用telnet的send命令给服务器发送数据，当我们连接多个命令行时，可以看到线程的id不一致，说明BIO是创建了多个线程去实现IO</p><h2 id="NIO模型"><a href="#NIO模型" class="headerlink" title="NIO模型"></a>NIO模型</h2><h3 id="什么是NIO模型"><a href="#什么是NIO模型" class="headerlink" title="什么是NIO模型"></a>什么是NIO模型</h3><p>Java NIO 全程Java non-Blocking IO，从Jdk1.4之后开始支持，是同步非阻塞的io模型，相关的类与接口定义在Java.nio包下，包里面对Java.IO包下的很多类进行改写，由Channel(管道)、Buffer(缓冲区)、Selector(选择器)三个核心部分组成，是面向缓冲区编程的，数据读取到缓冲区，需要时可在缓冲区中前后移动，增加了处理过程中的灵活性，从而提供非阻塞的高伸缩性网络。</p><p>当线程从通道中获得请求或者获取到数据时，线程会做出相应的处理，当没有数据时线程则可以去处理其它管道而不会导致线程阻塞。一个线程输入一些数据到达管道，但不需要等待它完全写入，这时线程同时可以去做别的事情。</p><h4 id="部件关系"><a href="#部件关系" class="headerlink" title="部件关系:"></a>部件关系:</h4><p>Channel与Buffer一一对应，一个Selector对应一个线程，一个Selector对应多个Channel。Channel需要到对应的Selector中注册，Selector会处理哪个Channel是由事件(event)决定的。Buffer是一个内存块，底层是一个数组，除了boolean类型，其它基本类型都支持。Buffer需要通过filp()方法改变读写模式。</p><p>常用的Channel类有FileChannel(文件管道，传输文件)、ServerSocketChannel(服务器套接字管道，TCP数据传输)、SocketChannel(套接字管道，TCP数据传输)、DatagramChannel(数据包管道，UDP数据传输)</p><p>Channel:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">String str = <span class="string">"Hello os"</span>;</span><br><span class="line"><span class="comment">// 创建文件输出流</span></span><br><span class="line">FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"E:\\test.txt"</span>);</span><br><span class="line"><span class="comment">// 获取输出流相应的管道</span></span><br><span class="line">FileChannel fileChannel = fileOutputStream.getChannel();</span><br><span class="line"><span class="comment">// 创建btye类型缓冲区</span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"><span class="comment">// 把字符串转换成byte格式放入缓冲区</span></span><br><span class="line">buffer.put(str.getBytes());</span><br><span class="line"><span class="comment">// 改变缓冲区的状态(将position置1)</span></span><br><span class="line">buffer.flip();</span><br><span class="line"><span class="comment">// 讲缓冲区写入管道</span></span><br><span class="line">fileChannel.write(buffer);</span><br><span class="line"><span class="comment">// 关闭管道</span></span><br><span class="line">fileOutputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是一个利用管道和缓冲区将字符串写入文件的demo，方便与理解管道和缓冲区的关系。</p><p>Selector:</p><h3 id="NIO流程"><a href="#NIO流程" class="headerlink" title="NIO流程"></a>NIO流程</h3><p><img src="/2020/04/17/bioModel/img/oneReactormoreThread.png" alt="BIOModle"></p><ol><li><p>服务器创建ServerSocketChannel来，绑定好连接的地址</p></li><li><p>创建Selector，并把ServerSocketChannel注册到Selector，设置事件，ServerSocketChannel是用于处理连接事件，注册时设置ops变量为SelectionKey.OP_ACCEPT。</p></li><li><p>服务器循环等待，直到客户端连接时，可以通过Selector.selectedKeys()方法获得触发了事件的SelectionKey的集合</p></li><li><p>当触发的事件是accept事件，我们使用serverSocketChannel的accept()方法，去为客户端生成相应的socketChannel</p></li><li><p>将socketChannel注册(register(Selector selector,int ops))到Selector上，注册后返回一个SelectionKey与该Selector关联</p></li><li><p>Selector进行监听select方法，返回发生了关心的事件的通道个数，使用selectedKeys()方法获得需要处理的SelectionKey，通过SelectionKey的channel()方法，获得SocketChannel，从而完成业务逻辑。</p><p>小结:Selector是面向Channel工作的，对于连接事件会专门用serverSocketChannel来处理，而对于客户端的数据交互则会用socketChannel来处理。初学的时候名字容易搞乱。</p></li></ol><h3 id="NIO相对于BIO做了什么优化"><a href="#NIO相对于BIO做了什么优化" class="headerlink" title="NIO相对于BIO做了什么优化"></a>NIO相对于BIO做了什么优化</h3><p>BIO是以流的方式处理数据，而NIO是以块的方式处理数据，效率高很多。</p><p>BIO基于字节流和字符流操作，而NIO基于Channel和Buffer进行操作，数据和缓冲区可以互相读取，Selector监听管道事件从而使得单个线程监听多个客户端的管道。</p><h3 id="NIO-demo"><a href="#NIO-demo" class="headerlink" title="NIO demo"></a>NIO demo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 创建ServerSocket管道</span></span><br><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"><span class="comment">// 管道绑定端口</span></span><br><span class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line"><span class="comment">// 设置管道非阻塞</span></span><br><span class="line">serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 创建选择器</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line"><span class="comment">// 把管道注册到选择器上</span></span><br><span class="line">serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"><span class="comment">// 循环等待连接事件</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">// 等一秒连接事件</span></span><br><span class="line"><span class="keyword">if</span> (selector.select(<span class="number">1000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"服务器等待1秒无连接"</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 就获取selectionKey集合</span></span><br><span class="line">Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line"><span class="comment">// 通过selectionKeys获得通道</span></span><br><span class="line">Iterator&lt;SelectionKey&gt; selectionIterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (selectionIterator.hasNext()) &#123;</span><br><span class="line">SelectionKey key = selectionIterator.next();</span><br><span class="line"><span class="comment">// 对于连接请求</span></span><br><span class="line">                <span class="comment">// ==================分割线=======================</span></span><br><span class="line"><span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line"><span class="comment">// 如果是连接请求，则给它生成一个管道</span></span><br><span class="line">SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line"><span class="comment">// 设置管道非阻塞</span></span><br><span class="line">socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 并把这个管道的读事件注册到选择器上</span></span><br><span class="line">socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对于读区事件</span></span><br><span class="line"><span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line"><span class="comment">// 获得key所对应的channel</span></span><br><span class="line">SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line"><span class="comment">// 获得key所对应的buffer</span></span><br><span class="line">ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line"><span class="comment">// 把chennel读取到的数据存入buffer中</span></span><br><span class="line">channel.read(buffer);</span><br><span class="line">System.out.println(<span class="string">"从客户端 获得"</span> + <span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">&#125;</span><br><span class="line">                <span class="comment">// ===================分割线=====================</span></span><br><span class="line">selectionIterator.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 创建socketChannel</span></span><br><span class="line">SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line"><span class="comment">// 设置非阻塞</span></span><br><span class="line">socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 设置连接地址</span></span><br><span class="line">InetSocketAddress inetSoccketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>,<span class="number">8080</span>);</span><br><span class="line"><span class="comment">// 连接服务器</span></span><br><span class="line"><span class="keyword">if</span>(!socketChannel.connect(inetSoccketAddress)) &#123;</span><br><span class="line"><span class="keyword">while</span>(!socketChannel.finishConnect()) &#123;</span><br><span class="line">System.out.println(<span class="string">"连接未完成，客户端继续其他工作"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">String str = <span class="string">"Hello?Can you hear me?"</span>;</span><br><span class="line"><span class="comment">// 将字符串放入缓冲区</span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.wrap(str.getBytes());</span><br><span class="line"><span class="comment">// 写入管道</span></span><br><span class="line">socketChannel.write(buffer);</span><br><span class="line">System.in.read();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码展示了一个简单的NIO服务器和客户端，讲述了NIO框架的部件之间的关系，尽管与BIO相比进行了优化但是仍然拥有许多问题：</p><ol><li>NIO的类库比较复杂，需要熟练掌握才能使用，</li><li>涉及到Reactor模式和多线程操作，对基础要求比较高</li><li>开发难度大，需要面对的问题比较多如客户端断线重连、网络闪断、半包读写、失败缓存、网络拥塞、异常流处理等问题</li><li>本身有Bug，如Epoll Bug，导致Selector空轮询，导致CPU占用率100%，直到jdk1.7问题仍然存在。(直到jdk 6u4才解决)</li></ol><h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><h3 id="了解Netty框架前需要的准备"><a href="#了解Netty框架前需要的准备" class="headerlink" title="了解Netty框架前需要的准备"></a>了解Netty框架前需要的准备</h3><h4 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式:"></a>Reactor模式:</h4><h5 id="Reactor模式-又称dispather模式-有两个核心组成部件"><a href="#Reactor模式-又称dispather模式-有两个核心组成部件" class="headerlink" title="Reactor模式(又称dispather模式)有两个核心组成部件:"></a>Reactor模式(又称dispather模式)有两个核心组成部件:</h5><ol><li>Reactor:(分配器)负责监听与分发事件，分发给适当的处理程序来对IO事件做出反应，可以通过Provider获得.</li><li>Handlers:(处理器)负责处理I/O事件要完成的实际事件</li></ol><h5 id="Reactor模式的构成"><a href="#Reactor模式的构成" class="headerlink" title="Reactor模式的构成:"></a>Reactor模式的构成:</h5><ol><li>Handle(句柄或是描述符):本质上是一种资源，有操作系统提供；该资源用于表示一个个的事件，比如说文件描述符，或是针对网络编程中的Socket描述符。是事件产生的发源地。</li><li>Synchronous Event Demultiplexer(同步事件分离器):本身是一个系统调用，用于等待事件的发生。调用方在调用它的时候会被阻塞，直到同步事件分离器上有事件为止。对应NIO组件里面的Selector；对应的阻塞方法是select()方法。</li><li>Event Handler(事件处理器):本身由多个回调方法构成，回调方法构成了与应用相关的对于某个时间的反馈机制。</li><li>Concrete Event Handler(具体事件处理器):是事件处理其的实现，本身实现了事件处理其所提供的各种回调方法，从而实现特定与业务的逻辑。</li><li>Initiation Dispatcher(初始分发器):实际上就是Selector。</li></ol><p>在NIO里面没有提供关于事件处理器和具体事件处理器的接口。</p><h5 id="分类"><a href="#分类" class="headerlink" title="分类:"></a>分类:</h5><h6 id="单Reactor单线程"><a href="#单Reactor单线程" class="headerlink" title="单Reactor单线程:"></a>单Reactor单线程:</h6><p>NIO的demo所使用模式就是单Reactor单线程的模式，其中Selector就担任着Reactor的角色，而在=号分割线中间的代码就是具体的handler(只是没有抽出来做成handler)。适合用在客户端数量有限，处理快的场景。</p><p>问题:</p><p>性能上:当并发量比较高的时候这种模型就会产生阻塞的问题，且无法发挥多核CPU的性能，Handler处理某个连接业务时会导致进程无法处理其它连接事件，导致性能瓶颈.</p><p>可靠性上:如果线程意外终止或者死循环，会导致整个系统通信模块不可用，不能接收或者处理外部信息造成节点故障。</p><h6 id="单Reactor多线程"><a href="#单Reactor多线程" class="headerlink" title="单Reactor多线程:"></a>单Reactor多线程:</h6><p><img src="/2020/04/17/bioModel/img/masterBackupReactor.png" alt="BIOModle"></p><p>流程:</p><ol><li>Reactor对象通过select监控客户端请求事件，收到事件之后进行分发</li><li>如果是建立连接的请求，则通过处理连接请求并创建Handler处理完成连接后的各种事件(accept方法生成管道注册到选择器这一系列操作)，</li><li>如果不是连接请求，则由eeactor分发调用连接相应的handler来处理</li><li>handler只处理响应时间，不处理具体业务逻辑，荣国read读取数据后，会分发给后面的worker线程池处理某个线程处理业务</li><li>worker线程池分配独立线程完成真正的业务，并将结果返回给handler。</li><li>handler收到响应之后，通过send将结果返回给client</li></ol><p>好处:可以充分利用多核CPU的能力</p><p>问题:多线程数据共享和访问比较复杂，不好维护，reactor处理所有的事件的监听与响应，在单线程运行，在高并发场景容易出现性能瓶颈(性能瓶颈出现在主线程的handler上，压力依然比较大)。</p><h6 id="主从Reactor多线程"><a href="#主从Reactor多线程" class="headerlink" title="主从Reactor多线程:"></a>主从Reactor多线程:</h6><p>Netty所使用的Reactor模式就是主从Reactor多 线程模式.</p><p>工作原理:</p><p>对于单Reactor多线程模型中，Reactor在单线程中运行，高并发场景下容易成为性能瓶颈，可以让Reactor在多线程中运行(谁压力大，就把谁扔到多线程里面处理)。</p><p>流程:</p><ol><li>Reactor主线程MainReactor对象通过select监听连接事件，都到事件后处理连接事件。(这点跟前面两个都一样)</li><li>处理连接事件后，MainReactor将连接分配给subReactor</li><li>subreactor将连接加入到连接队列进行监听，并创建handler进行各种事件处理</li><li>当有新事件发生时，subreactor就会调用对应的handler进行处理</li><li>handler通过read读取数据，分发给后面的worker线程处理，worker线程池分配独立的worker线程进行业务处理，并返回结果给handler。</li><li>handler收到结果后，用send将结果返回给client.</li></ol><p><img src="/2020/04/17/bioModel/img/masterBackupReactor.png" alt="BIOModle"></p><h5 id="简单总结区分"><a href="#简单总结区分" class="headerlink" title="简单总结区分"></a>简单总结区分</h5><p>单Reactor多线程相对于单Reactor单线程而言，把handler部分使用线程池机制实现了多路复用从而提高了性能，但是由于handler都挤在一个线程，当吞吐量较大的时候会有性能瓶颈；</p><p>主从Reactor多线程相对于单Reactor多线程增加了一个层Reactor，用于专门处理读写事件，当吞吐量较大的时候可以多用几个Reactor来分担吞吐量，从而解决性能瓶颈问题，再往下层也使用了线程池来多路复用。</p><h5 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h5><p>这个模式本身不依赖于业务逻辑，在编程中广泛使用如:Netty框架、Nginx和Memcached等</p><h4 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h4><h3 id="Netty框架详解"><a href="#Netty框架详解" class="headerlink" title="Netty框架详解"></a>Netty框架详解</h3><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><p><img src="/2020/04/17/bioModel/img/NettyFrame.jpg" alt="BIOModle"></p><p>Netty抽象出两组线程池，BossGroup专门负责处理接受客户端的连接，WorkerGroup专门负责处理网络读写。</p><p>两个线程池都是NioEventLoopGroup</p><p>NioEventLoopGroup相当于一个事件循环组，组中包含多个事件循环(NioEventLoop)。</p><p>NioEventLoop表示一个不断循环的执行处理任务的线程，每个NioEventLoop都有一个selector，用于监听绑定在其身上的socket的网络通讯。</p><p>BossNioEventLoop执行的步骤有三步:轮询；处理连接请求，获取连接对应的通道(NioSocketChannel)，将通道注册到Worker的Selector上；处理任务队列的任务(即处理队列的所有连接任务)。</p><p>WorkerNIOEventLoop执行步骤：轮询读写事件；处理事件，在对应的NioSockerChannel处理，处理任务队列的任务(即处理队列的所有读写任务)。</p><h4 id="TCP通讯demo"><a href="#TCP通讯demo" class="headerlink" title="TCP通讯demo"></a>TCP通讯demo</h4><h5 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码:"></a>服务端代码:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">nettyServer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建两个线程组</span></span><br><span class="line"><span class="comment"> * 其中bossGroup负责连接 workerGroup负责读写</span></span><br><span class="line"><span class="comment"> * 两个都是循环等待</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 设置启动服务器对象</span></span><br><span class="line">ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"><span class="comment">//配置启动参数,链式编程</span></span><br><span class="line">serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line"><span class="comment">// 设置通道类型</span></span><br><span class="line">.channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">// 设置线程队列得到连接个数(设置<span class="title">bossGroup</span>的<span class="title">Channel</span>属性)</span></span><br><span class="line"><span class="class">.<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>, 128)</span></span><br><span class="line"><span class="class">// 设置保持活动链接状态</span></span><br><span class="line"><span class="class">.<span class="title">childOption</span>(<span class="title">ChannelOption</span>.<span class="title">SO_KEEPALIVE</span>, <span class="title">true</span>)</span></span><br><span class="line"><span class="class">// 创建<span class="title">workerGroup</span>通道处理器</span></span><br><span class="line"><span class="class">.<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 处理器具体设置</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> nettyServerHandler());</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">"I'm Server,I'm ready"</span>);</span><br><span class="line"><span class="comment">// ChannelFuture是绑定成功后的回调对象，包含通道的各种信息</span></span><br><span class="line">ChannelFuture cf = serverBootstrap.bind(<span class="number">8080</span>).sync();</span><br><span class="line"><span class="comment">// 对关闭通道进行监听</span></span><br><span class="line">cf.channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">bossGroup.shutdownGracefully();</span><br><span class="line">workerGroup.shutdownGracefully();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="服务端处理器代码"><a href="#服务端处理器代码" class="headerlink" title="服务端处理器代码:"></a>服务端处理器代码:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义的Handler需要继承Netty所规定好的某个HandlerAdapter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ALEGANT</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">nettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取事件时对数据的操作</span></span><br><span class="line"><span class="comment"> * ctx包含上下文信息，包含pipeline和channel以及地址</span></span><br><span class="line"><span class="comment"> * msg客户端数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"ctx = "</span> + ctx);</span><br><span class="line">ByteBuf buffer = (ByteBuf)msg;</span><br><span class="line">System.out.println(<span class="string">"From "</span> + ctx.channel().remoteAddress() + <span class="string">" get msg : "</span> + buffer.toString(CharsetUtil.UTF_8));</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取数据完毕时对数据的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">"Get it,thank you"</span>,CharsetUtil.UTF_8));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发生异常后的处理 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ctx.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码:"></a>客户端代码:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">nettyClient</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 事件循环组</span></span><br><span class="line">EventLoopGroup clientGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 与服务端不同的是 客户端创建的是Bootstrap而不是ServerBootstrap</span></span><br><span class="line">Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line"><span class="comment">// 设置启动参数</span></span><br><span class="line">bootstrap.group(clientGroup)</span><br><span class="line"><span class="comment">// 设置通道的实现类型 注意 服务端的是NioServerSocketChannel 多了个Server</span></span><br><span class="line">.channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">// 设置管道处理器</span></span><br><span class="line"><span class="class">.<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> nettyClientHandler());</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">"I'm Client,I'm ready!"</span>);</span><br><span class="line"><span class="comment">// 连接服务端 关于ChannelFuture后面会继续讲解</span></span><br><span class="line">ChannelFuture cf = bootstrap.connect(<span class="string">"127.0.0.1"</span>, <span class="number">8080</span>).sync();</span><br><span class="line"><span class="comment">// 对关闭管道事件进行监听</span></span><br><span class="line">cf.channel().close().sync();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">clientGroup.shutdownGracefully();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="客户端处理器"><a href="#客户端处理器" class="headerlink" title="客户端处理器:"></a>客户端处理器:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">nettyClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据到达时触发方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Client:"</span> + ctx);</span><br><span class="line">ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">"hello,Server"</span>,CharsetUtil.UTF_8));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抛出异常时触发的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">cause.printStackTrace();</span><br><span class="line">ctx.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取事件时触发的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ByteBuf buf = (ByteBuf)msg;</span><br><span class="line">System.out.println(<span class="string">"Message From Server :"</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">System.out.println(<span class="string">"Server Address:"</span> + ctx.channel().remoteAddress());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个demo实现了最简单的使用Netty框架实现TCP通信，但是这么写还存在很多问题，例如粘包拆包、POJO的定义等等，而且如果对Netty没有了解的人会不清楚整个启动的流程以及一些Netty写好的类的功能及其意义，下面将一个一个点逐个击破。</p><h4 id="一些概念的补充"><a href="#一些概念的补充" class="headerlink" title="一些概念的补充:"></a>一些概念的补充:</h4><p>一开始讲过”Netty是一个异步的基于事件驱动的网络应用框架”，这里面有个异步的关键词还没有讲解，事件驱动通过前面的BIO/NIO等模型应该已经有个清楚的认知，就是发生了某件事之后去驱动另一个部件去做点什么。同样的，在Handler里面也是，把读写过程进行了拆分，并对读写过程的各个阶段进行包装。同时，还增加了回调对象(ChannelFuture)，用于同步或者异步处理。假如有某个业务耗时特别长，那么本质上在等待的过程还是阻塞的，我们需要让它进行异步执行。</p><h5 id="异步模型和ChannelFuture"><a href="#异步模型和ChannelFuture" class="headerlink" title="异步模型和ChannelFuture"></a>异步模型和ChannelFuture</h5><p>异步模型和同步模型相对立，同步模型在调用之后需要等待调用结果，而异步模型则不能立刻获得结果，实际处理调用的组件在完成后，通过状态、通知和回调通知调用者。</p><p>Netty的异步模型是建立在future和callback之上的，callback就是回调。future则是用于监控方法的处理过程。(通过future可以监控方法的处理过程)。</p><p>Netty中的I/O操作是异步的，在Bind()、Write()、Connect()等操作会简单的返回一个ChannelFuture，用户可以通过它提供的方法主动获取或者可以添加监听器，监听相应的事件，获得IO操作结果。拦截操作和转换出入站数据只需要提供callBack或者使用future即可。此外，注意ChannelFuture是一个接口，一般来说真正的实现类是DefaultChannelPromise，这个类由执行器和Channel构造而成，由原生JDK的Future接口改进而来，可以通过get()方法获得结果，但是值得注意的是这个方法是阻塞的，会等待到有结果为止，这个特性会导致一个问题，开发者不知道什么时候去调用get()方法，如果早了就需要等待，晚了事件响应就不及时，同样的原声JDK的isDone()方法对异步任务的完成结果描述不清晰、调用不方便，为此Netty对这个接口增加了关于Listener的一系列方法(addListener、removeListener等)，来增加事件性，并且还提供了isSuccess()方法来更加清晰地描述事件地结果，使得事件发生了之后直接响应事件而不需要主动去调用，从而提高性能。</p><p>代码中还会有channelFuture的sync()方法。这个sync()方法字面上理解就是同步的意思，实际上这个方法就是使得对应的ChannelFuture会去等待相应的结果，直到得到回调才会继续执行后续的代码。在理解了这点之后再去看看nettyServer的第31行，在服务器绑定了8080端口后，服务器会获得一个绑定了相应NioServerSocketChannel的ChannelFuture，然后对这个future监听closeFuture()事件并等待回调。进入debug模式进行逐步调试会发现，代码卡在了第33行，当本地Socket关闭了就会获得相应的回调并执行后续的两个shutdownGracefully()来释放系统资源。</p><p>ChannelFuture常用操作:</p><table><thead><tr><th>方法名</th><th>方法作用</th></tr></thead><tbody><tr><td>isDone</td><td>判断是否完成(正常完成、用户取消、抛出异常等)</td></tr><tr><td>isSuccess</td><td>判断当前操作是否成功</td></tr><tr><td>getCause</td><td>获取当前操作失败原因</td></tr><tr><td>isCancelled</td><td>判断已成功的操作是否被取消</td></tr><tr><td>addListener</td><td>注册监听器，操作完成会通知指定监听器</td></tr></tbody></table><h5 id="bootstrap、ServerBootstrap"><a href="#bootstrap、ServerBootstrap" class="headerlink" title="bootstrap、ServerBootstrap"></a>bootstrap、ServerBootstrap</h5><p>bootstrap是启动引导，Netty程序通常由一个Bootstrap开始，主要作用是配置整个Netty程序，设置各个组件。</p><p>bootstrap是客户端启动引导类，ServerBootstrap是服务器启动引导类，这两个类都是继承AbstractBootstrap这个抽象类，在实现时，会根据前面的设置(group()、channel()、option()等方法设置的参数)进行初始化，在设置参数时参数被保存，ServerBootstrap在调用bind()方法的时候(bootStrap在调用connect()方法)的时候，相关的Channel和ChannelFuture才会被构造，在内部使用了工厂模式，调用了前面传入的参数，通过反射来创造Channel实例，然后再对各个选项通过键值对的方式进行设值，其中ChannelOption里面有常量池，里面通过泛型的方式定义类对应设置所需要的参数类型。生成了Channel之后就会调用相应的init方法去执行设置的逻辑，对Channel类型、Channel设置等进行设置，可以留意到我们的代码(NettyServer的第18行-22行)里面有option和childOption这两个东西，与之前对应的这两个分别设置分别对应bossGroup和workGroup，我们对childHandler进行了设置但是没有对handler进行设置，这是因为在底层的初始化方法里面会在管道的的末尾增加接收器。</p><p>常见方法:</p><table><thead><tr><th>方法名</th><th>方法参数</th><th>方法作用</th><th>备注</th></tr></thead><tbody><tr><td>group</td><td>EventGroup,EventGroup</td><td>设置两个事件循环</td><td>用于服务器端</td></tr><tr><td>channel</td><td>Class&lt;? extends C&gt; channelClass</td><td>用来设置服务器端的通道实现</td><td></td></tr><tr><td>option</td><td>ChannelOption<T> , T</td><td>为parentGroup对应的Channel增加设置</td><td>根据泛型不同，值的类型可以变更</td></tr><tr><td>childOption</td><td>ChannelOption<T>,T</td><td>为childGroup对应的Channel增加设置</td><td></td></tr><tr><td>childHandler</td><td>childHandler</td><td>设置业务处理类</td><td>自定义Handler</td></tr><tr><td>bind</td><td>int</td><td>用于服务端，占用端口号</td><td></td></tr><tr><td>connect</td><td>String,int</td><td>用于客户端，链接服务器</td><td></td></tr></tbody></table><h5 id="Channel、Pipeline、Handler、ChannelHandlerContext"><a href="#Channel、Pipeline、Handler、ChannelHandlerContext" class="headerlink" title="Channel、Pipeline、Handler、ChannelHandlerContext"></a>Channel、Pipeline、Handler、ChannelHandlerContext</h5><p>pipeline是一个存放自定义的ChannelHandlerContext的容器，其数据结构为双向链表，本身不处理事件，链表元素是ChannelHandlerContext，ChannelHandlerContext则像绑定了Channel、Handler、用户所定义的Handler的别名、pipeline、EventExecutor等信息，使得通过ChannelHandlerContext可以获得所有的相关信息。不但如此，我们也可以通过单个节点推导前后的节点(双向链表的特性)，handler会对进栈和出栈的事件进行拦截操作，这些Handler负责相应的Channel的所有I/O事件(I/O事件都能注册相应的Handler以方便在事件进行到各个阶段的时候可以让被注册的Handler进行处理)。</p><table><thead><tr><th>名字</th><th>作用</th></tr></thead><tbody><tr><td>NioSocketChannel</td><td>异步的客户端TCP Socket连接</td></tr><tr><td>NioServerSocketChannel</td><td>异步的服务器端TCP Socket连接</td></tr><tr><td>NioDatagramChannel</td><td>异步的UDP连接</td></tr><tr><td>NioSctpChannel</td><td>异步的客户端stcp连接</td></tr><tr><td>NioSctpServerChannel</td><td>异步的服务端stcp连接，涵盖UDP和TCP网络IO以及文件IO</td></tr></tbody></table><h5 id="EventLoopGroup以及EventLoop"><a href="#EventLoopGroup以及EventLoop" class="headerlink" title="EventLoopGroup以及EventLoop"></a>EventLoopGroup以及EventLoop</h5><p>EventLoopGroup是事件循环组，它是一个接口，它对原生JDK的线程池进行了封装与改进，负责存储事件循环(也就是线程)，底层就是一个死循环(    for(;;){}或者while(ture){}    )。构造方法里会默认设置CPU核数 * 2个事件循环，一般来说BossGroup用来负责处理连接事件，因此设置参数为1，使得循环组只有1个线程。EventLoopGroup接口里面有next()方法，使得可以在循环组中迭代地获得事件循环。在初始化的时候，会设置监听器，并在事件初始化完成的时候设置回调。</p><h6 id="与其他组建的对应关系"><a href="#与其他组建的对应关系" class="headerlink" title="与其他组建的对应关系"></a>与其他组建的对应关系</h6><p>一个EventLoopGroup拥有一个或多个EventLoop</p><p>EventLoop在整个生命周期会与唯一一个线程绑定，并且它所处理的I/O事件都在这个线程上处理。</p><p>一个Channel只会注册在一个EventLoop上，一个EventLoop可以处理一个或多个Channel。</p><h6 id="推论"><a href="#推论" class="headerlink" title="推论:"></a>推论:</h6><p>因此可以将Channel的引用进行缓存，可以确定，在对一个Channel进行操作时，即使在多线程环境下也是线程安全的，因为所操作的channel是绑定在一个EventLoop中，而EventLoop与唯一的一个线程绑定，因此对这个channel的操作都是在这个线程里面，不会出现多线程的问题，并且消息会按照顺序进行发送。(即Channel与线程绑定，对这个Channel的操作是在同个线程里面，不会出现多线程的问题。)</p><p>同时在实际业务开发过程里，不要讲耗时长的任务放入EventLoop的执行队列当中，因为它会阻塞其它的Channel的IO，为此需要一个业务线程池，将实际的业务操作放入专门的业务线程池。</p><p>常用的处理方式:</p><ol><li>在ChannelHandler的回调方法里面使用自定义的业务线程池</li><li>使用Netty提供的addLast(EventExecutorGroup group, ChannelHandler… handlers)方法(方法位于ChannelInitializer的initChannel方法获得pipeline，调用pipeline拥有此方法)，把具体任务放入业务线程池。(注意:对应的回调方法会在对应的Handler所在的线程组里面执行。)</li></ol><h4 id="粘包拆包以及编码解码"><a href="#粘包拆包以及编码解码" class="headerlink" title="粘包拆包以及编码解码"></a>粘包拆包以及编码解码</h4><p>Netty使用的模式是Reactor模式，而Reactor模式是面向块编程，当Selector获取到事件之后，去读取缓存区的数据，如果在短时间内缓存区的数据没有被读取(在一个读取间隔，同个Channel接收到多次数据)，那么这时候如果不做处理，框架将会出现粘包的问题，因此我们需要对数据进行处理，防止这个问题的出现。</p><p>对于这个问题，Netty在内部使用了internal包下的TypeParameterMatcher以确保传入参数类型的正确性，并检查类型，对于一般的业务逻辑，我们可以使用ObjectEncoder来实现POJO类的编码，也可以自己编写编码器和解码器，自需要继承ByteToMessageDecoder类并重写相应的Decode方法(MessageToByteEncoder重写Encode方法)，就可以编写与自身业务逻辑相应的编解码器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SquareDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx,ByteBuf in, List&lt;Object&gt; out)</span> </span>&#123;</span><br><span class="line"><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">out.add(in.readBytes(in.readableBytes()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是ByteToMessageDecoder源码中的Demo，in就是缓存区的内容，out是存放解码的结果的容器，解码成功后在相应的handler可以获得对应的POJO。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Netty框架的发展及其基础&quot;&gt;&lt;a href=&quot;#Netty框架的发展及其基础&quot; class=&quot;headerlink&quot; title=&quot;Netty框架的发展及其基础&quot;&gt;&lt;/a&gt;Netty框架的发展及其基础&lt;/h1&gt;&lt;p&gt;“Netty is an asynchron
      
    
    </summary>
    
    
    
      <category term="Netty" scheme="http://ALEGANT.github.io/tags/Netty/"/>
    
      <category term="BIO" scheme="http://ALEGANT.github.io/tags/BIO/"/>
    
      <category term="NIO" scheme="http://ALEGANT.github.io/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="http://alegant.github.io/2020/04/09/JavaBase/"/>
    <id>http://alegant.github.io/2020/04/09/JavaBase/</id>
    <published>2020-04-09T08:47:42.000Z</published>
    <updated>2020-04-20T08:00:07.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java集合类基础-collection"><a href="#Java集合类基础-collection" class="headerlink" title="Java集合类基础 - collection"></a>Java集合类基础 - collection</h1><p>前言:在讲一些知识点之前先结合这需求来进行剖析，因为代码终究是为需求服务的，这里的需求不仅仅是指产品，就算是程序员也是有需求的，程序员需要一些具体的工具去进行高效率的开发，脱离了需求讲代码其实是不太合理的，就像阐明一件事情要遵守STAR原则一样，要把Situation（情景）、Task（任务）、Action（行动）和Result（结果）结合起来，因此在这里养成个小小的习惯，尽可能地遵守STAR原则。</p><p>目录:</p><p><a href="#整体框架">整体框架</a></p><p><a href="#继承树">继承树</a></p><p><a href="#Collection接口">Collection接口</a></p><p><a href="#Map接口">Map接口</a></p><p><a href="#AbstractCollection下的区别">AbstractCollection下的区别</a></p><p>-<a href="#AbstractList下的区别">AbstractList下的区别</a></p><p>-<a href="#AbstractQueue类型的区别">AbstractQueue类型的区别</a></p><p>-<a href="#AbstractSet类型的区别">AbstractSet类型的区别</a></p><p><a href="#AbstractMap类型的区别">AbstractMap类型的区别</a></p><p><a href="#两个特殊的结构">两个特殊的结构</a></p><h2 id="地位"><a href="#地位" class="headerlink" title="地位"></a>地位</h2><p>Java的集合类在Java开发过程中占据着重要的角色，无论是架构层面上还是业务层面上，都是不可或缺的重要一环。在架构上，我们常常用Map&lt;String,Class&gt;这样的一个集合去存储类名和它相应的Class,以便于在生产过程中直接通过类名(服务名)去获得相应的对象，或者把符合条件的Class放入列表中统一加载，再或者从业务的角度来看，我们常常需要用集合去实现具体的业务逻辑，例如达成某条件A的人与达成B条件的人的交、并、补集，这些都是可以通过集合去实现的。</p><p>网上关于Collection的内容太多了，在这里我想做的事情是做一些简单的证明和对于源码的解析。而且跟自己立下的规矩一样，我会用代码和图片的形式展现出来。</p><p>对于代码的学习，我的个人习惯是先看继承关系，然后看接口，因为一些类的方法不只是写在这个类本身上，而是写在父类(对于抽象的父类来说，则一般是实现了某个接口，至少有相关方法的声明，否则子类编译会报出”*** must implement the inherited abstract method”的错误)。从这个角度出发，我们来看看Collection这个类。</p><h2 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h2><p><img src="/2020/04/09/JavaBase/img/Collection.png" alt="frame"></p><h3 id="继承树"><a href="#继承树" class="headerlink" title="继承树"></a>继承树</h3><p>关于collection的继承关系，我们可以通过‘进入源码-查询引用’去查看，关于接口也可以在类的声明出找到。以下特性是在jdk1.8的环境下生效。<br><img src="/2020/04/09/JavaBase/img/CollectionFrame.png" alt="继承图"><br>这里的继承关系是通过观察代码得到的，只引用了java.util包下的集合，可以发现关于源码，设计者们对于每个容器都定义了相应的接口，而且接口之间和类一样有相应的继承关系，在类的定义上层层递进，接口的定义上也是层层递进，最后根据不同的类写出具体的实现方法，这里也体现出设计师面向接口编程的理念。<br>对于AbstractList、AbstractSet、AbstractQueue他们都是继承了AbstractCollection这个类,而AbstractCollection引用了Collection这个接口，因此需要实现这些方法;<br>如下表格:<br>为了称呼方便 我们把参数中的集合称为集合B 调用这个方法的集合称为集合A</p><table><thead><tr><th>接口名</th><th>返回类型</th><th>参数类型</th><th>接口描述</th><th>备注</th></tr></thead><tbody><tr><td>size()</td><td>int</td><td>无</td><td>获得集合大小</td><td></td></tr><tr><td>isEmpty()</td><td>boolean</td><td>无</td><td>判断集合是否为空</td><td></td></tr><tr><td>contains(Object)</td><td>boolean</td><td>Object</td><td>判断集合是否含有该元素</td><td>这里面的参数类型是Object,不会受到声明集合时的泛型限制</td></tr><tr><td>toArray()</td><td>Object[]</td><td>无</td><td>讲集合中的元素转换成对象数组</td><td></td></tr><tr><td>toArray(T[])</td><td><T> T[]</td><td>讲集合中的元素转换成泛型数组</td><td>泛型方法</td><td></td></tr><tr><td>add()</td><td>boolean</td><td>E</td><td>向集合中加入元素</td><td>元素E是声明容器时所选用的类型.编译时会检查类型是否匹配.</td></tr><tr><td>remove(Object)</td><td>boolean</td><td>Object</td><td>容器中移除目标元素</td><td>移除的是目标的引用,并不会对对象本身造成影响.</td></tr><tr><td>containsAll(Collection&lt;? extends E&gt;)</td><td>boolean</td><td>Collection&lt;? exteds E&gt;</td><td>判断集合B是否集合A的子集</td><td>这里的参数收到了限制，必须是存放’继承了E的元素’的集合</td></tr><tr><td>addAll(Collection&lt;? extends E&gt;)</td><td>boolean</td><td>Collection&lt;? exteds E&gt;</td><td>将集合B的所有元素加入到集合A中</td><td>参数中的集合存放的对象必须是E类或者E的子类</td></tr><tr><td>removeAll(Collection&lt;?&gt;)</td><td>boolean</td><td>Collection&lt;?&gt;</td><td>移除集合A中所有的集合B的元素</td><td>集合B存放的类型没有限制</td></tr><tr><td>removeIf(Predicate&lt;? super E&gt;)</td><td>boolean</td><td>Predicate&lt;? super E&gt;</td><td>移除集合A中符合条件的元素</td><td>Predicate需要重写评估方法</td></tr><tr><td>clear()</td><td>void</td><td>无</td><td>清空集合</td><td></td></tr><tr><td>equals(Object)</td><td>boolean</td><td>Object</td><td>判断集合是否等价</td><td>根据子类重写的方法判定是值相同还是引用相同</td></tr><tr><td>hashCode()</td><td>int</td><td>无</td><td>获得集合的hashCode</td><td>Object类的方法</td></tr><tr><td>spliterator()</td><td>spliterator</td><td>无</td><td>迭代器</td><td>分割遍历</td></tr><tr><td>Stream()</td><td>Stream</td><td>无</td><td>将集合转换成流</td><td>支持并发</td></tr><tr><td>parllelStream()</td><td>Stream</td><td>无</td><td>将集合转换成流</td><td></td></tr></tbody></table><p>从Collection接口所定义的方法我们可以看出来，Collection就是实现数学中的集合的思想，实现了集合的交并补的逻辑运算，而在具体的方法定义中，我们也可以看出来，在处理集合过程中集合元素的的范围和数学中的集合思想如出一辙。举个例子:</p><hr><p>containsAll(Collection&lt;? extends E&gt;)这个方法,集合B的元素必须是E的子类，类比到数学中就相当于集合B的元素类型必须是集合A的元素类型的子类型。假设A是有理数集，那么B的元素不能是比A的元素(有理数)更高级，但是可以更低级，所以B不能是无理数(比有理数范围大)，可以是自然数(比有理数范围小)，当然集合B(例如说集合B是映射的集合)不能是跟集合A毫无联系的集合，因为这样就毫无可比性。</p><p>Collection的派生接口里面有List、Set、Queue接口，分别和AbstractList、AbstractSet、AbstractQueue相对应。所以只要从这几个接口入手，就等再一次划分这几个集合的区别；</p><h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口:"></a>Collection接口:</h3><p>对于Collection下的各种容器的区分,从”结构决定性质，性质决定用途”的观点出发，我们先要了解这些容器实现了什么接口，才能让这些容器发挥最好的用途。</p><h4 id="List"><a href="#List" class="headerlink" title="List:"></a>List:</h4><p>List接口与Collection接口相比增加了下列方法:</p><table><thead><tr><th>接口名</th><th>返回类型</th><th>参数类型</th><th>接口描述</th><th>备注</th></tr></thead><tbody><tr><td>get(int)</td><td>E</td><td>int</td><td>获取对应下标的元素</td><td>获取下表前需要检查</td></tr><tr><td>set(int,E)</td><td>E</td><td>int,E</td><td>设置对应下表的元素</td><td>设置前检查下标</td></tr><tr><td>add(int,E)</td><td>void</td><td>int,E</td><td>对应位置增加元素</td><td></td></tr><tr><td>remove(int)</td><td>E</td><td>int</td><td>移除对应下表的元素</td><td></td></tr><tr><td>subList(int,int)</td><td>List<E></td><td>int,int</td><td>切割列表</td><td>注意切割时是直接对列表操作还是对引用进行操作(对存储模板的数据更加要小心)</td></tr><tr><td>indexOf(Object)</td><td>int</td><td>Object</td><td>获取对象在列表中的下标(顺序)</td><td>注意空对象和内部对比对象时的执行方法,一般为参数对象是null会执行==操作,否则执行.equals(element[i])的操作</td></tr><tr><td>lastIndexOf(Object)</td><td>int</td><td>Object</td><td>获取对象在列表中的下标(倒序)</td><td>注意事项同上</td></tr></tbody></table><p>从接口上看来，List容器与下标有着密不可分的关系。</p><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue:"></a>Queue:</h4><table><thead><tr><th>接口名</th><th>返回类型</th><th>参数类型</th><th>接口描述</th><th>备注</th></tr></thead><tbody><tr><td>add(E)</td><td>boolean</td><td>E</td><td>往队列中增加元素</td><td></td></tr><tr><td>offer(E)</td><td>boolean</td><td>E</td><td>往队列中增加元素</td><td>会有增加失败的情况出现</td></tr><tr><td>remove()</td><td>E</td><td>无</td><td>移除队头元素</td><td>如果队列是空会抛出异常</td></tr><tr><td>poll()</td><td>E</td><td>无</td><td>移除队头元素</td><td>如果队列为空会返回null</td></tr><tr><td>element()</td><td>E</td><td>无</td><td>获取队头元素</td><td>只获取不移除，同时如果队列为空会抛出异常</td></tr><tr><td>peek()</td><td>E</td><td>无</td><td>获取队头元素</td><td>只获取不移除，同时如果队列为空会返回null</td></tr></tbody></table><p>从接口上看来,Queue容器不注重下标，但是重视容器的头部。</p><h4 id="Set"><a href="#Set" class="headerlink" title="Set:"></a>Set:</h4><p>Set接口同Collection接口相比几乎一致。唯一不同的是，Set拥有一个子接口SortedSet<E></p><h4 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet:"></a>SortedSet<E>:</h4><table><thead><tr><th>接口名</th><th>返回类型</th><th>参数类型</th><th>接口描述</th><th>备注</th></tr></thead><tbody><tr><td>comparator()</td><td>Comparator&lt;? super E&gt;</td><td>无</td><td>获得比较器</td><td>SortedSet对Set集合进行了排序操作，需要重写Comparable方法</td></tr><tr><td>subSet(E,E)</td><td>SortedSet<E></td><td>E,E</td><td>分组,获取子集</td><td></td></tr><tr><td>headSet(E)</td><td>SortedSet<E></td><td>E</td><td>获取大于E的分组</td><td></td></tr><tr><td>tailSet(E)</td><td>SortedSet<E></td><td>E</td><td>获取小于E的分组</td><td></td></tr><tr><td>first()</td><td>E</td><td>无</td><td>获取排序后的第一个元素</td><td></td></tr><tr><td>last()</td><td>E</td><td>无</td><td>获取排序后的最后一个元素</td><td></td></tr></tbody></table><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口:"></a>Map接口:</h3><table><thead><tr><th>接口名</th><th>返回类型</th><th>参数类型</th><th>接口描述</th><th>备注</th></tr></thead><tbody><tr><td>size(E)</td><td>int</td><td></td><td>获得map容器的大小</td><td></td></tr><tr><td>isEmpty()</td><td>boolean</td><td></td><td>是否为空</td><td></td></tr><tr><td>containsKey(Object o)</td><td>boolean</td><td>Object</td><td>Key的集合是否包含参数o</td><td></td></tr><tr><td>containsValue(Object o)</td><td>boolean</td><td>Object</td><td>Value的集合是否包含参数o</td><td></td></tr><tr><td>get(Object o)</td><td>V</td><td>Object</td><td>获得参数Key所对应的值</td><td></td></tr><tr><td>put(K k,V v)</td><td>V</td><td>V</td><td>将键值对放入容器中</td><td></td></tr><tr><td>remove(Object o)</td><td>V</td><td>Object</td><td>移除容器中的元素</td><td>参数中的Object与Key对应</td></tr><tr><td>putAll(Map&lt;? extends K, ? extends V&gt;)</td><td>无</td><td>Map&lt;? extends K, ? extends V&gt;</td><td>把map容器B的所有元素加入map容器A中</td><td>类型检查</td></tr><tr><td>clear()</td><td>无</td><td>无</td><td>清空map容器中的所有元素</td><td></td></tr><tr><td>keySet()</td><td>Set<K></td><td>无</td><td>返回所有Key的集合</td><td>返回的类型是Set，是无序的。</td></tr><tr><td>values()</td><td>Collection<V></td><td>无</td><td>返回所有Values的集合</td><td>返回类型是Collection，可以使用Collection接口的所有方法。</td></tr><tr><td>entrySet()</td><td>Set&lt;Entry&lt;K,V&gt;&gt;</td><td>无</td><td>返回所有的键值对</td><td></td></tr><tr><td>equals(Object o)</td><td>boolean</td><td>Object</td><td>判断集合是否等价</td><td></td></tr><tr><td>hashCode()</td><td>int</td><td>无</td><td>获得容器的哈希码</td><td>Object类的方法</td></tr><tr><td>getOrDefault(Object,V)</td><td>V</td><td>Object,V</td><td>获得key所对饮的值，否则返回默认值</td><td>可以防止空指针的问题</td></tr><tr><td>replace(K k, V v)</td><td>V</td><td>K k, V v</td><td>替换原有Key中的value</td><td></td></tr><tr><td>replace(K k, V v, V v)</td><td>boolean</td><td>K k, V v, V v</td><td>替换原有Key中的元素</td><td></td></tr><tr><td>putIfAbsent(K key, V value)</td><td>V</td><td>K key, V value</td><td>往容器中加入键值对，如果已经存在了对应Key则不加入并返回原有的Value</td><td></td></tr><tr><td>remove(Object key, Object value)</td><td>boolean</td><td>Object key, Object value</td><td>移除目标键值对</td><td></td></tr><tr><td>computeIfAbsent(K key,            Function&lt;? super K, ? extends V&gt; mappingFunction)</td><td>V</td><td>K key, Function&lt;? super K, ? extends V&gt; mappingFunction</td><td>当key存在返回当前value值，key不存在则执行函数并保存到map中</td><td><a href="https://blog.csdn.net/u010938610/article/details/82622144" target="_blank" rel="noopener">参考文章</a></td></tr><tr><td>computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)</td><td>V</td><td>K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction</td><td>指定的 在map中已经存在的key的value进行操作。只对已经存在key的进行操作，否则不操作</td><td><a href="https://blog.csdn.net/u010938610/article/details/82622144" target="_blank" rel="noopener">参考文章</a></td></tr><tr><td>forEach(BiConsumer&lt;? super K, ? super V&gt; action)</td><td>无</td><td>BiConsumer&lt;? super K, ? super V&gt; action</td><td>定义了一个对所有Key和Value操作的接口</td><td></td></tr><tr><td>replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function)</td><td>无</td><td>BiFunction&lt;? super K, ? super V, ? extends V&gt; function</td><td>定义一个可按照自定义规则把新值替换旧值的接口</td><td></td></tr><tr><td>compute(K key,        BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)</td><td>V</td><td>K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction</td><td>指定的key在map中的值进行操作 不管存不存在，操作完成后保存到map中</td><td><a href="https://blog.csdn.net/u010938610/article/details/82622144" target="_blank" rel="noopener">参考文章</a></td></tr><tr><td>merge(K key, V value,            BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction)</td><td>V</td><td>K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction</td><td>当map中不存在指定的key时，便将传入的value设置为key的值，当key存在值时，执行一个方法该方法接收key的旧值和传入的value，执行自定义的方法返回最终结果设置为key的值。</td><td></td></tr></tbody></table><h4 id="关于Map的接口涉及到jdk8的新特性"><a href="#关于Map的接口涉及到jdk8的新特性" class="headerlink" title="关于Map的接口涉及到jdk8的新特性:"></a>关于Map的接口涉及到jdk8的新特性:</h4><p><a href="https://www.runoob.com/java/java8-new-features.html" target="_blank" rel="noopener">Java8新特性</a>比较常用的几个及教程可以支持函数式编程，虽然可读性没那么强但是写起来比较简洁。</p><h4 id="一些小想法"><a href="#一些小想法" class="headerlink" title="一些小想法:"></a>一些小想法:</h4><p>接口本身就是对类的方法进行抽象，接口继承接口的这种做法以我的理解是对功能进行分级，越具有共性的方法所在的接口的等级就越高，这也是为什么Collection接口是作为一个顶级接口声明的，因为无论是List,Queue,Set这些接口都具备Collection接口所声明的功能，或者我们可以用细胞来类比，接口的继承就类似于细胞的分化，分工逐渐明确。</p><h3 id="AbstractCollection下的区别"><a href="#AbstractCollection下的区别" class="headerlink" title="AbstractCollection下的区别:"></a>AbstractCollection下的区别:</h3><p>对于各个容器接下来会按照不同的接口实现来简单的划分，划分的时候会结合源码去说一点细节，对于比较常见的问题就放开不谈。</p><h4 id="AbstractList类型的区别"><a href="#AbstractList类型的区别" class="headerlink" title="AbstractList类型的区别:"></a>AbstractList类型的区别:</h4><p>讲在前面的一些方法:</p><hr><p>System.arraycopy(Object src,  int  srcPos, Object dest, int destPos, int length)    (1)</p><hr><p><a href="https://segmentfault.com/a/1190000009922279" target="_blank" rel="noopener">这里</a>有关于方法的讲解，方法的作用是把”src[srcPos]作为起点把后续的length个位置”替换成以”dest[destPos]作为起点，后续length个元素”的方法。</p><hr><p>ensureCapacityInternal(int minCapacity)     (2)</p><p>grow(int minCapacity)    (3)</p><hr><p>(2)方法是检测参数是否在列表的的范围内，(3)方法是数组扩容。这个方法会在ArrayList和Vector中被调用。</p><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList:"></a>ArrayList:</h5><p>ArrayList的底层数据结构是数组，有3种构造方式，当使用无参构造时默认长度为10，当使用int做参数时，参数为数组大小，当参数为集合时，内部会调用Collection接口的toArray()方法把集合转成数组。</p><p>既然底层是数组，那么有几个东西需要提前分清楚，length是指底层数组的实际长度，size是容器的一个属性，是表示容器真正存了多少元素的标记，以及index是每个元素所在的位置。(这里先讲清楚，防止后面乱了)</p><p>在ArrayList里面有sort()方法，需要传入比较器，内部会调用Arrays工具类的sort()方法，这里对于工具内部的sort()方法暂不做深究(这个会在本文最后讲工具类Arrays的时候讲解)，主要研究对象还是ArrayList。前面说到ArrayList默认的构造方法会设置10个元素的空位(对应element[])，当插入元素在超过length时，ArrayList会自动扩容，扩大原来的length的1.5倍，从而实现动态长度，因为这里已经经过了扩容，可以确保数组的长度足够，因此不用在内部使用for循环来调用add(index,e)方法从而提高性能，为了处理这个问题提供了trimToSize()方法，使得ArrayList可以把尾部多余的null元素剔除。</p><p>indexOf(Object o)和lastIndexOf(Object o)会遍历(分别对应顺序和倒序)一次数组.内部执行equals()方法。</p><p>clone()方法返回了一个对象，克隆是通过数组的复制实现的，属于浅拷贝，同样的toArray()方法也是浅拷贝。同时返回值是Object类型，因此在使用的时候要注意强转，复制好的对象会重置modCount。</p><h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector:"></a>Vector:</h5><p>Vector容器与ArrayList大致相同，但是在线程安全上它在方法上都会有synchronized关键字，说明这个容器是线程安全的；同时Vector的扩容机制与ArrayList不相同，Vector每次扩容容量翻倍。</p><h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList:"></a>LinkedList:</h5><p>linkedList的数据结构是链表，因此在数据的增加与删除上更具有优势(时间复杂度O(1))而在随机查询方面(O(n))性能不如ArrayList。</p><p>LinkedList的get(index)方法会先判断index与size的关系，如果小于size/2就顺序遍历，否则倒序遍历，当数据量大的时候，用for循环去调用get()方法，性能上的损失是非常大的。</p><p>同时在扩容机制上链表更具备优势，链表只需要在’对应下标节点的前一个节点’的next指针指向’被插入的节点’，然后把被插入的节点的next指针指向’原先对应下标节点’就可以完成插入操作，LinkedList还实现了Queue接口，并且在内部拥有Node<E> first和Node<E> last变量，这使得它具有队列的特性。</p><hr><p>更新分割线2020-04-09,后续继续更新</p><p>写完结构发现这个主题要写完的话需要大量时间，现在先把讲解的框架定好，后续再持续更新，按照接触到的顺序和常用程度进行不定期更新。</p><hr><h4 id="AbstractQueue类型的区别"><a href="#AbstractQueue类型的区别" class="headerlink" title="AbstractQueue类型的区别:"></a>AbstractQueue类型的区别:</h4><h5 id="AsLIFOQueue"><a href="#AsLIFOQueue" class="headerlink" title="AsLIFOQueue:"></a>AsLIFOQueue:</h5><h5 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue:"></a>PriorityQueue:</h5><h4 id="Concurrent包下的Queue"><a href="#Concurrent包下的Queue" class="headerlink" title="Concurrent包下的Queue:"></a>Concurrent包下的Queue:</h4><h5 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue:"></a>ArrayBlockingQueue:</h5><h5 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue:"></a>ConcurrentLinkedQueue:</h5><h5 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue:"></a>DelayQueue:</h5><h5 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue:"></a>LinkedBlockingQueue:</h5><h5 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue:"></a>LinkedTransferQueue:</h5><h5 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue:"></a>PriorityBlockingQueue:</h5><h5 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue:"></a>SynchronousQueue:</h5><h4 id="AbstractSet类型的区别"><a href="#AbstractSet类型的区别" class="headerlink" title="AbstractSet类型的区别:"></a>AbstractSet类型的区别:</h4><h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet:"></a>HashSet:</h5><h5 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet:"></a>LinkedHashSet:</h5><h5 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet:"></a>TreeSet:</h5><h4 id="AbstractMap类型的区别"><a href="#AbstractMap类型的区别" class="headerlink" title="AbstractMap类型的区别:"></a>AbstractMap类型的区别:</h4><h5 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap:"></a>HashMap:</h5><p>HashMap是生产过程中基本不会离开的一种数据结构，也是最有典型意义的键值对类型。</p><p>在jdk1.7的时候，HashMap的内部结构是以Entry&lt;K,V&gt;作为元素，以数组+链表作为结构，当我们往hash表中添加一个对象时，会调用对象的hashcode()方法，算出对应的数组的索引值，再根据索引值查找数组，数组中是否存在对象，如果不存在对象直接存进去。如果存在对象(即两个对象的HashCode相等，但是不是同个对象，这个现象成为碰撞)，则通过euqals()方法比较两个对象的key值是否相等，如果相等则覆盖value值，否则产生链表并对链表内的元素进行逐个比较，通过这个方法，减少了equals()方法的使用次数从而提高性能。</p><p>在Jdk1.8时，HashMap的内部结构是Node&lt;K,V&gt;，以数组+链表+RBTree(一种树状的数据结构，由二叉搜索树衍生，特点是左节点小于根节点，右节点大于根节点)作为结构，原理和1.7差不多，在map长度超过64时就会进行树化改造，将链表转换成BRTree，这个做法通过牺牲了插入和删除的性能提高了查找的性能，因为RBTree的插入比较复杂，时间复杂度是大于链表的。(关于红黑树的具体细节我会在后续算法相关的文章中讲解)</p><p>在HashMap生成时，会设置负载因子，这个负载因子的默认值是0.75。0.75这个数字是对时间与空间的折衷，如果取1，则空间使用率达到最高，但是冲突的机会更大，如果小了，碰撞就会减少，但是会浪费空间。简而言之：负载因子越大，冲突机会越大，查找成本越大，空间利用率高，反之负载银子越小，冲突机会越小，查找成本越小，空间利用率越低。</p><p>讲在前面的方法:</p><p>resize():</p><hr><p>因为jdk1.8对HashMap进行了优化</p><p>jdk1.7:</p><p>存放新值时发生了hash碰撞，同时size++大于等于阈值时会扩容。</p><p>扩容时会用transfer()方法把原数组的值放入新数组，然后设置新的阈值。(桶满了，换个大点的桶装)</p><p>其中这里的transfer()方法会对原来的数组进行遍历，如果数组的元素产生了链表，则对这个链表的每个元素进行rehash，重新计算哈希值，从而把链表中的元素分布到数组里，从而减少链表的数量提高查询性能。</p><p>注意如果当前容量已经达到最大时不扩容。</p><p>但是在多线程的环境下，如果多个线程访问了同一个HashMap，就会出现死循环的问题，具体<a href="https://blog.csdn.net/maohoo/article/details/81531925" target="_blank" rel="noopener">死循环的原因</a>。</p><p>jdk1.8:</p><p>jdk1.8的resize()方法前部分的判断和jdk1.7的判断大致相同，同时把transfer()部分的代码合并到resize()方法里，因为增加了红黑树的结构，transfer()方法的变动比较大，当桶中只有节点数为1时，重新计算节点的散列，使其分布到其它位置，如果桶中节点数大于1，此时重新区分情况，当桶中是链表时，会把链表一分为二，使得原来的桶里一半的节点保留在原桶，另外一半的元素分布到之前所在桶的下标+oldCap，即转移到原有下标+原来的size，区分条件是用Hash值与扩容前的size做与运算；当桶中是红黑树时，需要对它进行拆分，形成链表，然后再同样地会遍历链表节点后将部分元素映射到新桶里。</p><p>hash():</p><hr><p>jdk1.7的hash算法就是简单地key mod table.length。</p><p>jdk1.8的hash算法是key取出key的hashCode的高16位然后与自身异或，从而得到数组下标。为了散布更均匀，因此不用&amp;使得结果偏向0或者使用|使得结果偏向1。</p><p>讲完了前面的方法我们再回过头来看，HashMap的定义方式和Collection的方式类似，一种是无参构造，无参构造会默认生成大小为16，负载因子0.75的HashMap。另外一种是以Map为参数的构造方式则会调用putMapEntries()方法，在这个方法里会重新计算Map的阈值和设定数组的大小，具体做法是把当前的size - 1,然后与自身的右移1、2、4、8、16位做或运算，得出新的阈值，如果map的大小大于阈值则进行resize()，通过putVal()方法把参数的所有节点加入到散列中。</p><p>putVal()方法会把参数的变量转换成节点，计算Hash值之后加入到散列桶里，根据桶里已有元素的类型，执行相应的插入逻辑。当链表长度超过8或者数组长度达到64，则会把链表转换成RBTree.</p><h5 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap:"></a>ConcurrentHashMap:</h5><p>底层也是通过数组+链表的方法实现，Key与Value都不允许为null</p><p>通过把整个Map拆分成N个Segment，使用了分段锁技术，对每一段数据分配一个锁，使得当一个锁被一个线程占有时，其他段的数据也能被访问，从而提高性能。</p><p>Segment基本上和HashMap一样。</p><h5 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap:"></a>ConcurrentSkipListMap:</h5><h5 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap:"></a>LinkedHashMap:</h5><h5 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap:"></a>WeakHashMap:</h5><h5 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap:"></a>EnumMap:</h5><h5 id="SortedMap"><a href="#SortedMap" class="headerlink" title="SortedMap:"></a>SortedMap:</h5><h5 id="IdentityHashMap"><a href="#IdentityHashMap" class="headerlink" title="IdentityHashMap:"></a>IdentityHashMap:</h5><h5 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap:"></a>TreeMap:</h5><h4 id="两个特殊的结构"><a href="#两个特殊的结构" class="headerlink" title="两个特殊的结构:"></a>两个特殊的结构:</h4><h5 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable:"></a>Hashtable:</h5><p>底层实现是数组+链表，无论Key还是Value都不允许为null.保持线程安全的方式是锁住整个HashTable，效率较低。</p><h5 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque:"></a>ArrayDeque:</h5><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java集合类基础-collection&quot;&gt;&lt;a href=&quot;#Java集合类基础-collection&quot; class=&quot;headerlink&quot; title=&quot;Java集合类基础 - collection&quot;&gt;&lt;/a&gt;Java集合类基础 - collection&lt;/
      
    
    </summary>
    
    
    
      <category term="Java" scheme="http://ALEGANT.github.io/tags/Java/"/>
    
      <category term="基础" scheme="http://ALEGANT.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="集合" scheme="http://ALEGANT.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://alegant.github.io/2020/04/08/HelloWorld/"/>
    <id>http://alegant.github.io/2020/04/08/HelloWorld/</id>
    <published>2020-04-07T17:50:00.000Z</published>
    <updated>2020-04-13T06:50:42.195Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><h2 id="千里之行始于足下-前言"><a href="#千里之行始于足下-前言" class="headerlink" title="千里之行始于足下  - 前言"></a>千里之行始于足下  - 前言</h2><h3 id="开博客目的"><a href="#开博客目的" class="headerlink" title="开博客目的"></a>开博客目的</h3><p>俗话说的好:万事开头难。搭建这个博客就是迈出第一步，在我的个人意愿中,我一直是把自己定位成一个纯粹的Java后端开发工程师,对于页面的编写或者修改常常因为这个定位而推诿逃避页面的编写，直到某一天的失眠让我重新评价审视自己的定位和能力，重新认识并定位自己，认识到自己的主观意愿和我的客观行动并没有达成一致，也就是俗称的’思想的巨人,行动的矮子’。已经毕业了半年了，从学生思维跳出来，转到社会人的角度，既然发现了问题，那当然第一个反应是评判后果并修改啦。<br>自身的问题:</p><table><thead><tr><th>评价维度</th><th>描述</th></tr></thead><tbody><tr><td>优先级</td><td>最高级,一个连自己都不重视的人怎么可能去做好别的事</td></tr><tr><td>影响程度</td><td>长期不动手，导致动手能力不足，加上视线的拓展变得眼高手低，不学无术</td></tr><tr><td>修正难度</td><td>养成习惯的级别，要三个月才能养成好一个习惯</td></tr></tbody></table><p>简单评估下问题和影响，这些影响和后果大多建立在经验所得，但是重要的是这个问题的解决方案的落实，就像我常常挂在嘴边的一句话:”不要听说了什么，要看做了什么”。这也是我开始写博客的一个原因，一是落实自己的计划并做出点什么成果出来，其次是修正并发现自身的问题，最后也是给自己一个交待，虽说看起来有点逼着自己的感觉，就像立flag一样，但是啊，人不逼一下自己怎么知道自己行不行呢。</p><hr><h3 id="个人想法"><a href="#个人想法" class="headerlink" title="个人想法"></a>个人想法</h3><p>既然是开张第一天，那么就多碎碎念几句，做事先做人，这里可以当成是一个自我介绍，也可以当作是我的个人的世界观的体现。<br>世界观决定方法论，方法论体现世界观。所以我很崇拜那些有思想的人，更崇拜那些能在自己的领域或者岗位上有所作为的人，<br>这些有所作为的人他们做到了善，而且他们用实际行动证明了自己的能力，并将自己的能力这一抽象概念转换成了客观的存在。<br>这里就关系到一个问题，什么叫好的程序员。以下是一些我的个人观点</p><h4 id="从专业素养的角度来看："><a href="#从专业素养的角度来看：" class="headerlink" title="从专业素养的角度来看："></a>从专业素养的角度来看：</h4><p>一个程序员的评判标准应当是他在程序设计过程中所设计的代码的优越度而不是程序本身，</p><p>如果我们把一个程序的用户体验作为一个程序员的评判标准，这是很荒唐的，因为这是程序设计本身的问题，或者说这是用了评判产品的标准来评判了一个程序员。</p><h4 id="其次从传承的角度来看"><a href="#其次从传承的角度来看" class="headerlink" title="其次从传承的角度来看:"></a>其次从传承的角度来看:</h4><p>在程序员之间，好的代码思维跟可维护性强的代码是让程序得以维护的一个重要因素，</p><p>同时这也使得程序员之间的思想传承得到了保障，站在一个崇高的角度看，这是有限的程序员生涯中给无限的编程史留下了自己的一笔。</p><h4 id="从社会责任的角度来看"><a href="#从社会责任的角度来看" class="headerlink" title="从社会责任的角度来看:"></a>从社会责任的角度来看:</h4><p>如果一个程序员拥有了绝佳的技术却依仗这自己的技术胡作非为，这显然不是一个好的程序员所拥有的品质，我认为当技术达到相当程度后应该是应当静下心来，要么为编程文化做出自己的贡献，让编程的文明得以传承；要么在自己的岗位上发光发热，成为国家或者社会中无法被取代的一员；也可以选择成为文明探索的先锋，去突破当前的学术难题。</p><hr><h3 id="小小的规划"><a href="#小小的规划" class="headerlink" title="小小的规划"></a>小小的规划</h3><p>今天(2020年4月8日),算是这个博客正式营业的第一天,在这里先给自己定下一些目标和给自己一些约束，为后续的写文立下一些规范和保存一份习惯。</p><h4 id="给自己的约束"><a href="#给自己的约束" class="headerlink" title="给自己的约束"></a>给自己的约束</h4><h5 id="博客的更新频率"><a href="#博客的更新频率" class="headerlink" title="博客的更新频率"></a>博客的更新频率</h5><p>在我大学的时候其实就已经想经营一个技术博客，但是因为一些时间原因和个人原因，这个想法一直没有被落实，这也是一个小小的遗憾。但是现在一方面是时间比较充裕，二是所学技能需要沉淀，因此在开始的前几天会更新比较多的内容————补上大学时的坑和总结工作以来的技能。</p><h5 id="文档规范-期望"><a href="#文档规范-期望" class="headerlink" title="文档规范(期望)"></a>文档规范(期望)</h5><p>一、文档编写的时候要画思维导图<br>二、表格意识，加强对比<br>三、尽可能用容易理解的话来讲代码<br>四、不要写水文，尽可能多干货，结合自己地理解<br>五、写文内容以技术为主但不承诺只写技术相关内容<br>六、注重版权意识，引文或灵感来源要尊重原作者<br>七、下期预告</p><p>背景图片来自百度<a href="https://image.baidu.com/search/detail?ct=503316480&z=0&ipn=d&word=hello%20World&step_word=&hs=0&pn=0&spn=0&di=220&pi=0&rn=1&tn=baiduimagedetail&is=0%2C0&istype=0&ie=utf-8&oe=utf-8&in=&cl=2&lm=-1&st=undefined&cs=1905138384%2C486113505&os=2339458242%2C3019850321&simid=3382509924%2C256788667&adpicid=0&lpn=0&ln=1736&fr=&fmq=1586281832450_R&fm=&ic=undefined&s=undefined&hd=undefined&latest=undefined&copyright=undefined&se=&sme=&tab=0&width=undefined&height=undefined&face=undefined&ist=&jit=&cg=&bdtype=0&oriquery=&objurl=http%3A%2F%2Fi2.hdslb.com%2Fbfs%2Farchive%2F2209be24c1a5c0684a4b0771d04ce39b61e9db1a.jpg&fromurl=ippr_z2C%24qAzdH3FAzdH3Fooo_z%26e3Bdn9tgu5_z%26e3Bv54AzdH3FfAzdH3Fijss5%2Bo56s1&gsm=1&rpstart=0&rpnum=0&islist=&querylist=&force=undefined" target="_blank" rel="noopener">helloWorld</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hello-World&quot;&gt;&lt;a href=&quot;#Hello-World&quot; class=&quot;headerlink&quot; title=&quot;Hello World&quot;&gt;&lt;/a&gt;Hello World&lt;/h1&gt;&lt;h2 id=&quot;千里之行始于足下-前言&quot;&gt;&lt;a href=&quot;#千里之行始于
      
    
    </summary>
    
    
    
      <category term="helloWorld" scheme="http://ALEGANT.github.io/tags/helloWorld/"/>
    
      <category term="简介" scheme="http://ALEGANT.github.io/tags/%E7%AE%80%E4%BB%8B/"/>
    
  </entry>
  
</feed>
