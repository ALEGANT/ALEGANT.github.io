<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Alegant&#39;s技术博客</title>
  
  <subtitle>桃李无言，下自成蹊</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://alegant.github.io/"/>
  <updated>2020-04-18T15:11:24.030Z</updated>
  <id>http://alegant.github.io/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java基础</title>
    <link href="http://alegant.github.io/2020/04/09/JavaBase/"/>
    <id>http://alegant.github.io/2020/04/09/JavaBase/</id>
    <published>2020-04-09T08:47:42.000Z</published>
    <updated>2020-04-18T15:11:24.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java集合类基础-collection"><a href="#Java集合类基础-collection" class="headerlink" title="Java集合类基础 - collection"></a>Java集合类基础 - collection</h1><p>前言:在讲一些知识点之前先结合这需求来进行剖析，因为代码终究是为需求服务的，这里的需求不仅仅是指产品，就算是程序员也是有需求的，程序员需要一些具体的工具去进行高效率的开发，脱离了需求讲代码其实是不太合理的，就像阐明一件事情要遵守STAR原则一样，要把Situation（情景）、Task（任务）、Action（行动）和Result（结果）结合起来，因此在这里养成个小小的习惯，尽可能地遵守STAR原则。</p><h2 id="地位"><a href="#地位" class="headerlink" title="地位"></a>地位</h2><p>Java的集合类在Java开发过程中占据着重要的角色，无论是架构层面上还是业务层面上，都是不可或缺的重要一环。在架构上，我们常常用Map&lt;String,Class&gt;这样的一个集合去存储类名和它相应的Class,以便于在生产过程中直接通过类名(服务名)去获得相应的对象，或者把符合条件的Class放入列表中统一加载，再或者从业务的角度来看，我们常常需要用集合去实现具体的业务逻辑，例如达成某条件A的人与达成B条件的人的交、并、补集，这些都是可以通过集合去实现的。</p><p>网上关于Collection的内容太多了，在这里我想做的事情是做一些简单的证明和对于源码的解析。而且跟自己立下的规矩一样，我会用代码和图片的形式展现出来。</p><p>对于代码的学习，我的个人习惯是先看继承关系，然后看接口，因为一些类的方法不只是写在这个类本身上，而是写在父类(对于抽象的父类来说，则一般是实现了某个接口，至少有相关方法的声明，否则子类编译会报出”*** must implement the inherited abstract method”的错误)。从这个角度出发，我们来看看Collection这个类。</p><h2 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h2><p><img src="/2020/04/09/JavaBase/img/CollectionFrame.png" alt="frame"></p><h2 id="继承树"><a href="#继承树" class="headerlink" title="继承树"></a>继承树</h2><p>关于collection的继承关系，我们可以通过‘进入源码-查询引用’去查看，关于接口也可以在类的声明出找到。以下特性是在jdk1.8的环境下生效。<br><img src="/2020/04/09/JavaBase/img/Collection.png" alt="继承图"><br>这里的继承关系是通过观察代码得到的，只引用了java.util包下的集合，可以发现关于源码，设计者们对于每个容器都定义了相应的接口，而且接口之间和类一样有相应的继承关系，在类的定义上层层递进，接口的定义上也是层层递进，最后根据不同的类写出具体的实现方法，这里也体现出设计师面向接口编程的理念。<br>对于AbstractList、AbstractSet、AbstractQueue他们都是继承了AbstractCollection这个类,而AbstractCollection引用了Collection这个接口，因此需要实现这些方法;<br>如下表格:<br>为了称呼方便 我们把参数中的集合称为集合B 调用这个方法的集合称为集合A</p><table><thead><tr><th>接口名</th><th>返回类型</th><th>参数类型</th><th>接口描述</th><th>备注</th></tr></thead><tbody><tr><td>size()</td><td>int</td><td>无</td><td>获得集合大小</td><td></td></tr><tr><td>isEmpty()</td><td>boolean</td><td>无</td><td>判断集合是否为空</td><td></td></tr><tr><td>contains(Object)</td><td>boolean</td><td>Object</td><td>判断集合是否含有该元素</td><td>这里面的参数类型是Object,不会受到声明集合时的泛型限制</td></tr><tr><td>toArray()</td><td>Object[]</td><td>无</td><td>讲集合中的元素转换成对象数组</td><td></td></tr><tr><td>toArray(T[])</td><td><T> T[]</td><td>讲集合中的元素转换成泛型数组</td><td>泛型方法</td><td></td></tr><tr><td>add()</td><td>boolean</td><td>E</td><td>向集合中加入元素</td><td>元素E是声明容器时所选用的类型.编译时会检查类型是否匹配.</td></tr><tr><td>remove(Object)</td><td>boolean</td><td>Object</td><td>容器中移除目标元素</td><td>移除的是目标的引用,并不会对对象本身造成影响.</td></tr><tr><td>containsAll(Collection&lt;? extends E&gt;)</td><td>boolean</td><td>Collection&lt;? exteds E&gt;</td><td>判断集合B是否集合A的子集</td><td>这里的参数收到了限制，必须是存放’继承了E的元素’的集合</td></tr><tr><td>addAll(Collection&lt;? extends E&gt;)</td><td>boolean</td><td>Collection&lt;? exteds E&gt;</td><td>将集合B的所有元素加入到集合A中</td><td>参数中的集合存放的对象必须是E类或者E的子类</td></tr><tr><td>removeAll(Collection&lt;?&gt;)</td><td>boolean</td><td>Collection&lt;?&gt;</td><td>移除集合A中所有的集合B的元素</td><td>集合B存放的类型没有限制</td></tr><tr><td>removeIf(Predicate&lt;? super E&gt;)</td><td>boolean</td><td>Predicate&lt;? super E&gt;</td><td>移除集合A中符合条件的元素</td><td>Predicate需要重写评估方法</td></tr><tr><td>clear()</td><td>void</td><td>无</td><td>清空集合</td><td></td></tr><tr><td>equals(Object)</td><td>boolean</td><td>Object</td><td>判断集合是否等价</td><td>根据子类重写的方法判定是值相同还是引用相同</td></tr><tr><td>hashCode()</td><td>int</td><td>无</td><td>获得集合的hashCode</td><td>Object类的方法</td></tr><tr><td>spliterator()</td><td>spliterator</td><td>无</td><td>迭代器</td><td>分割遍历</td></tr><tr><td>Stream()</td><td>Stream</td><td>无</td><td>将集合转换成流</td><td>支持并发</td></tr><tr><td>parllelStream()</td><td>Stream</td><td>无</td><td>将集合转换成流</td><td></td></tr></tbody></table><p>从Collection接口所定义的方法我们可以看出来，Collection就是实现数学中的集合的思想，实现了集合的交并补的逻辑运算，而在具体的方法定义中，我们也可以看出来，在处理集合过程中集合元素的的范围和数学中的集合思想如出一辙。举个例子:</p><hr><p>containsAll(Collection&lt;? extends E&gt;)这个方法,集合B的元素必须是E的子类，类比到数学中就相当于集合B的元素类型必须是集合A的元素类型的子类型。假设A是有理数集，那么B的元素不能是比A的元素(有理数)更高级，但是可以更低级，所以B不能是无理数(比有理数范围大)，可以是自然数(比有理数范围小)，当然集合B(例如说集合B是映射的集合)不能是跟集合A毫无联系的集合，因为这样就毫无可比性。</p><p>Collection的派生接口里面有List、Set、Queue接口，分别和AbstractList、AbstractSet、AbstractQueue相对应。所以只要从这几个接口入手，就等再一次划分这几个集合的区别；</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口:"></a>接口:</h3><p>对于Collection下的各种容器的区分,从”结构决定性质，性质决定用途”的观点出发，我们先要了解这些容器实现了什么接口，才能让这些容器发挥最好的用途。</p><h4 id="List接口"><a href="#List接口" class="headerlink" title="List接口:"></a>List接口:</h4><p>List接口与Collection接口相比增加了下列方法:</p><table><thead><tr><th>接口名</th><th>返回类型</th><th>参数类型</th><th>接口描述</th><th>备注</th></tr></thead><tbody><tr><td>get(int)</td><td>E</td><td>int</td><td>获取对应下标的元素</td><td>获取下表前需要检查</td></tr><tr><td>set(int,E)</td><td>E</td><td>int,E</td><td>设置对应下表的元素</td><td>设置前检查下标</td></tr><tr><td>add(int,E)</td><td>void</td><td>int,E</td><td>对应位置增加元素</td><td></td></tr><tr><td>remove(int)</td><td>E</td><td>int</td><td>移除对应下表的元素</td><td></td></tr><tr><td>subList(int,int)</td><td>List<E></td><td>int,int</td><td>切割列表</td><td>注意切割时是直接对列表操作还是对引用进行操作(对存储模板的数据更加要小心)</td></tr><tr><td>indexOf(Object)</td><td>int</td><td>Object</td><td>获取对象在列表中的下标(顺序)</td><td>注意空对象和内部对比对象时的执行方法,一般为参数对象是null会执行==操作,否则执行.equals(element[i])的操作</td></tr><tr><td>lastIndexOf(Object)</td><td>int</td><td>Object</td><td>获取对象在列表中的下标(倒序)</td><td>注意事项同上</td></tr></tbody></table><p>从接口上看来，List容器与下标有着密不可分的关系。</p><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue:"></a>Queue:</h4><table><thead><tr><th>接口名</th><th>返回类型</th><th>参数类型</th><th>接口描述</th><th>备注</th></tr></thead><tbody><tr><td>add(E)</td><td>boolean</td><td>E</td><td>往队列中增加元素</td><td></td></tr><tr><td>offer(E)</td><td>boolean</td><td>E</td><td>往队列中增加元素</td><td>会有增加失败的情况出现</td></tr><tr><td>remove()</td><td>E</td><td>无</td><td>移除队头元素</td><td>如果队列是空会抛出异常</td></tr><tr><td>poll()</td><td>E</td><td>无</td><td>移除队头元素</td><td>如果队列为空会返回null</td></tr><tr><td>element()</td><td>E</td><td>无</td><td>获取队头元素</td><td>只获取不移除，同时如果队列为空会抛出异常</td></tr><tr><td>peek()</td><td>E</td><td>无</td><td>获取队头元素</td><td>只获取不移除，同时如果队列为空会返回null</td></tr></tbody></table><p>从接口上看来,Queue容器不注重下标，但是重视容器的头部。</p><h4 id="Set"><a href="#Set" class="headerlink" title="Set:"></a>Set:</h4><p>Set接口同Collection接口相比几乎一致。唯一不同的是，Set拥有一个子接口SortedSet<E></p><h4 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet:"></a>SortedSet<E>:</h4><table><thead><tr><th>接口名</th><th>返回类型</th><th>参数类型</th><th>接口描述</th><th>备注</th></tr></thead><tbody><tr><td>comparator()</td><td>Comparator&lt;? super E&gt;</td><td>无</td><td>获得比较器</td><td>SortedSet对Set集合进行了排序操作，需要重写Comparable方法</td></tr><tr><td>subSet(E,E)</td><td>SortedSet<E></td><td>E,E</td><td>分组,获取子集</td><td></td></tr><tr><td>headSet(E)</td><td>SortedSet<E></td><td>E</td><td>获取大于E的分组</td><td></td></tr><tr><td>tailSet(E)</td><td>SortedSet<E></td><td>E</td><td>获取小于E的分组</td><td></td></tr><tr><td>first()</td><td>E</td><td>无</td><td>获取排序后的第一个元素</td><td></td></tr><tr><td>last()</td><td>E</td><td>无</td><td>获取排序后的最后一个元素</td><td></td></tr></tbody></table><p>Map&lt;K,V&gt;:</p><table><thead><tr><th>接口名</th><th>返回类型</th><th>参数类型</th><th>接口描述</th><th>备注</th></tr></thead><tbody><tr><td>size(E)</td><td>int</td><td></td><td>获得map容器的大小</td><td></td></tr><tr><td>isEmpty()</td><td>boolean</td><td></td><td>是否为空</td><td></td></tr><tr><td>containsKey(Object o)</td><td>boolean</td><td>Object</td><td>Key的集合是否包含参数o</td><td></td></tr><tr><td>containsValue(Object o)</td><td>boolean</td><td>Object</td><td>Value的集合是否包含参数o</td><td></td></tr><tr><td>get(Object o)</td><td>V</td><td>Object</td><td>获得参数Key所对应的值</td><td></td></tr><tr><td>put(K k,V v)</td><td>V</td><td>V</td><td>将键值对放入容器中</td><td></td></tr><tr><td>remove(Object o)</td><td>V</td><td>Object</td><td>移除容器中的元素</td><td>如果同个Object对应了不同的Key,删除规则的制订可能有坑.</td></tr><tr><td>putAll(Map&lt;? extends K, ? extends V&gt;)</td><td>无</td><td>Map&lt;? extends K, ? extends V&gt;</td><td>把map容器B的所有元素加入map容器A中</td><td>类型检查</td></tr><tr><td>clear()</td><td>无</td><td>无</td><td>清空map容器中的所有元素</td><td></td></tr><tr><td>keySet()</td><td>Set<K></td><td>无</td><td>返回所有Key的集合</td><td>返回的类型是Set，是无序的。</td></tr><tr><td>values()</td><td>Collection<V></td><td>无</td><td>返回所有Values的集合</td><td>返回类型是Collection，可以使用Collection接口的所有方法。</td></tr><tr><td>entrySet()</td><td>Set&lt;Entry&lt;K,V&gt;&gt;</td><td>无</td><td>返回所有的键值对</td><td></td></tr><tr><td>equals(Object o)</td><td>boolean</td><td>Object</td><td>判断集合是否等价</td><td></td></tr><tr><td>hashCode()</td><td>int</td><td>无</td><td>获得容器的哈希码</td><td>Object类的方法</td></tr><tr><td>getOrDefault(Object,V)</td><td>V</td><td>Object,V</td><td>获得key所对饮的值，否则返回默认值</td><td>可以防止空指针的问题</td></tr><tr><td>replace(K k, V v)</td><td>V</td><td>K k, V v</td><td>替换原有Key中的value</td><td></td></tr><tr><td>replace(K k, V v, V v)</td><td>boolean</td><td>K k, V v, V v</td><td>替换原有Key中的元素</td><td></td></tr><tr><td>putIfAbsent(K key, V value)</td><td>V</td><td>K key, V value</td><td>往容器中加入键值对，如果已经存在了对应Key则不加入并返回原有的Value</td><td></td></tr><tr><td>remove(Object key, Object value)</td><td>boolean</td><td>Object key, Object value</td><td>移除目标键值对</td><td></td></tr><tr><td>computeIfAbsent(K key,            Function&lt;? super K, ? extends V&gt; mappingFunction)</td><td>V</td><td>K key, Function&lt;? super K, ? extends V&gt; mappingFunction</td><td>当key存在返回当前value值，key不存在则执行函数并保存到map中</td><td><a href="https://blog.csdn.net/u010938610/article/details/82622144" target="_blank" rel="noopener">参考文章</a></td></tr><tr><td>computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)</td><td>V</td><td>K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction</td><td>指定的 在map中已经存在的key的value进行操作。只对已经存在key的进行操作，否则不操作</td><td><a href="https://blog.csdn.net/u010938610/article/details/82622144" target="_blank" rel="noopener">参考文章</a></td></tr><tr><td>forEach(BiConsumer&lt;? super K, ? super V&gt; action)</td><td>无</td><td>BiConsumer&lt;? super K, ? super V&gt; action</td><td>定义了一个对所有Key和Value操作的接口</td><td></td></tr><tr><td>replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function)</td><td>无</td><td>BiFunction&lt;? super K, ? super V, ? extends V&gt; function</td><td>定义一个可按照自定义规则把新值替换旧值的接口</td><td></td></tr><tr><td>compute(K key,        BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)</td><td>V</td><td>K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction</td><td>指定的key在map中的值进行操作 不管存不存在，操作完成后保存到map中</td><td><a href="https://blog.csdn.net/u010938610/article/details/82622144" target="_blank" rel="noopener">参考文章</a></td></tr><tr><td>merge(K key, V value,            BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction)</td><td>V</td><td>K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction</td><td>当map中不存在指定的key时，便将传入的value设置为key的值，当key存在值时，执行一个方法该方法接收key的旧值和传入的value，执行自定义的方法返回最终结果设置为key的值。</td><td></td></tr></tbody></table><h5 id="关于Map的接口涉及到jdk8的新特性"><a href="#关于Map的接口涉及到jdk8的新特性" class="headerlink" title="关于Map的接口涉及到jdk8的新特性:"></a>关于Map的接口涉及到jdk8的新特性:</h5><p><a href="https://www.runoob.com/java/java8-new-features.html" target="_blank" rel="noopener">Java8新特性</a>比较常用的几个及教程可以支持函数式编程，虽然可读性没那么强但是写起来比较简洁。</p><h5 id="一些小想法"><a href="#一些小想法" class="headerlink" title="一些小想法:"></a>一些小想法:</h5><p>接口本身就是对类的方法进行抽象，接口继承接口的这种做法以我的理解是对功能进行分级，越具有共性的方法所在的接口的等级就越高，这也是为什么Collection接口是作为一个顶级接口声明的，因为无论是List,Queue,Set这些接口都具备Collection接口所声明的功能，或者我们可以用细胞来类比，接口的继承就类似于细胞的分化，分工逐渐明确。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别:"></a>区别:</h3><p>对于各个容器接下来会按照不同的接口实现来简单的划分，划分的时候会结合源码去说一点细节，对于比较常见的问题就放开不谈。</p><h4 id="List类型的区别"><a href="#List类型的区别" class="headerlink" title="List类型的区别:"></a>List类型的区别:</h4><p>讲在前面的一些方法:</p><hr><p>System.arraycopy(Object src,  int  srcPos, Object dest, int destPos, int length)    (1)</p><hr><p><a href="https://segmentfault.com/a/1190000009922279" target="_blank" rel="noopener">这个</a>面有关于方法的讲解，方法的作用是把”src[srcPos]作为起点把后续的length个位置”替换成以”dest[destPos]作为起点，后续length个元素”的方法。</p><hr><p>ensureCapacityInternal(int minCapacity)     (2)</p><p>grow(int minCapacity)    (3)</p><hr><p>(2)方法是检测参数是否在列表的的范围内，(3)方法是数组扩容。这个方法会在ArrayList和Vector中被调用。</p><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList:"></a>ArrayList:</h5><p>ArrayList的底层数据结构是数组，有3种构造方式，当使用无参构造时默认长度为10，当使用int做参数时，参数为数组大小，当参数为集合时，内部会调用Collection接口的toArray()方法把集合转成数组。</p><p>既然底层是数组，那么有几个东西需要提前分清楚，length是指底层数组的实际长度，size是容器的一个属性，是表示容器真正存了多少元素的标记，以及index是每个元素所在的位置。(这里先讲清楚，防止后面乱了)</p><p>在ArrayList里面有sort()方法，需要传入比较器，内部会调用Arrays工具类的sort()方法，这里对于工具内部的sort()方法暂不做深究(这个会在本文最后讲工具类Arrays的时候讲解)，主要研究对象还是ArrayList。前面说到ArrayList默认的构造方法会设置10个元素的空位(对应element[])，当插入元素在超过length时，ArrayList会自动扩容，扩大原来的length的1.5倍，从而实现动态长度，为了处理这个问题提供了trimToSize()方法，使得ArrayList可以把尾部多余的null元素剔除。</p><p>indexOf(Object o)和lastIndexOf(Object o)会遍历(分别对应顺序和倒序)一次数组.内部执行equals()方法。</p><p>clone()方法返回了一个对象，克隆是通过数组的复制实现的，属于浅拷贝，同样的toArray()方法也是浅拷贝。同时返回值是Object类型，因此在使用的时候要注意强转，复制好的对象会重置modCount。</p><h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector:"></a>Vector:</h5><p>Vector容器与ArrayList大致相同，但是在线程安全上它在方法上都会有synchronized关键字，说明这个容器是线程安全的；同时Vector的扩容机制与ArrayList不相同，Vector每次扩容容量翻倍。</p><h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList:"></a>LinkedList:</h5><p>linkedList的数据结构是链表，因此在数据的增加与删除上更具有优势(时间复杂度O(1))而在随机查询方面(O(n))性能不如ArrayList。</p><hr><p>LinkedList的get(index)方法会先判断index与size的关系，如果小于size/2就顺序遍历，否则倒序遍历，当数据量大的时候，用for循环去调用get()方法，性能上的损失是非常大的。</p><hr><p>同时在扩容机制上链表更具备优势，链表只需要在’对应下标节点的前一个节点’的next指针指向’被插入的节点’，然后把被插入的节点的next指针指向’原先对应下标节点’就可以完成插入操作，LinkedList还实现了Queue接口，并且在内部拥有Node<E> first和Node<E> last变量，这使得它具有队列的特性。</p><hr><p>更新分割线2020-04-09</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java集合类基础-collection&quot;&gt;&lt;a href=&quot;#Java集合类基础-collection&quot; class=&quot;headerlink&quot; title=&quot;Java集合类基础 - collection&quot;&gt;&lt;/a&gt;Java集合类基础 - collection&lt;/
      
    
    </summary>
    
    
    
      <category term="Java" scheme="http://ALEGANT.github.io/tags/Java/"/>
    
      <category term="基础" scheme="http://ALEGANT.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="集合" scheme="http://ALEGANT.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://alegant.github.io/2020/04/08/HelloWorld/"/>
    <id>http://alegant.github.io/2020/04/08/HelloWorld/</id>
    <published>2020-04-07T17:50:00.000Z</published>
    <updated>2020-04-13T06:50:42.195Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><h2 id="千里之行始于足下-前言"><a href="#千里之行始于足下-前言" class="headerlink" title="千里之行始于足下  - 前言"></a>千里之行始于足下  - 前言</h2><h3 id="开博客目的"><a href="#开博客目的" class="headerlink" title="开博客目的"></a>开博客目的</h3><p>俗话说的好:万事开头难。搭建这个博客就是迈出第一步，在我的个人意愿中,我一直是把自己定位成一个纯粹的Java后端开发工程师,对于页面的编写或者修改常常因为这个定位而推诿逃避页面的编写，直到某一天的失眠让我重新评价审视自己的定位和能力，重新认识并定位自己，认识到自己的主观意愿和我的客观行动并没有达成一致，也就是俗称的’思想的巨人,行动的矮子’。已经毕业了半年了，从学生思维跳出来，转到社会人的角度，既然发现了问题，那当然第一个反应是评判后果并修改啦。<br>自身的问题:</p><table><thead><tr><th>评价维度</th><th>描述</th></tr></thead><tbody><tr><td>优先级</td><td>最高级,一个连自己都不重视的人怎么可能去做好别的事</td></tr><tr><td>影响程度</td><td>长期不动手，导致动手能力不足，加上视线的拓展变得眼高手低，不学无术</td></tr><tr><td>修正难度</td><td>养成习惯的级别，要三个月才能养成好一个习惯</td></tr></tbody></table><p>简单评估下问题和影响，这些影响和后果大多建立在经验所得，但是重要的是这个问题的解决方案的落实，就像我常常挂在嘴边的一句话:”不要听说了什么，要看做了什么”。这也是我开始写博客的一个原因，一是落实自己的计划并做出点什么成果出来，其次是修正并发现自身的问题，最后也是给自己一个交待，虽说看起来有点逼着自己的感觉，就像立flag一样，但是啊，人不逼一下自己怎么知道自己行不行呢。</p><hr><h3 id="个人想法"><a href="#个人想法" class="headerlink" title="个人想法"></a>个人想法</h3><p>既然是开张第一天，那么就多碎碎念几句，做事先做人，这里可以当成是一个自我介绍，也可以当作是我的个人的世界观的体现。<br>世界观决定方法论，方法论体现世界观。所以我很崇拜那些有思想的人，更崇拜那些能在自己的领域或者岗位上有所作为的人，<br>这些有所作为的人他们做到了善，而且他们用实际行动证明了自己的能力，并将自己的能力这一抽象概念转换成了客观的存在。<br>这里就关系到一个问题，什么叫好的程序员。以下是一些我的个人观点</p><h4 id="从专业素养的角度来看："><a href="#从专业素养的角度来看：" class="headerlink" title="从专业素养的角度来看："></a>从专业素养的角度来看：</h4><p>一个程序员的评判标准应当是他在程序设计过程中所设计的代码的优越度而不是程序本身，</p><p>如果我们把一个程序的用户体验作为一个程序员的评判标准，这是很荒唐的，因为这是程序设计本身的问题，或者说这是用了评判产品的标准来评判了一个程序员。</p><h4 id="其次从传承的角度来看"><a href="#其次从传承的角度来看" class="headerlink" title="其次从传承的角度来看:"></a>其次从传承的角度来看:</h4><p>在程序员之间，好的代码思维跟可维护性强的代码是让程序得以维护的一个重要因素，</p><p>同时这也使得程序员之间的思想传承得到了保障，站在一个崇高的角度看，这是有限的程序员生涯中给无限的编程史留下了自己的一笔。</p><h4 id="从社会责任的角度来看"><a href="#从社会责任的角度来看" class="headerlink" title="从社会责任的角度来看:"></a>从社会责任的角度来看:</h4><p>如果一个程序员拥有了绝佳的技术却依仗这自己的技术胡作非为，这显然不是一个好的程序员所拥有的品质，我认为当技术达到相当程度后应该是应当静下心来，要么为编程文化做出自己的贡献，让编程的文明得以传承；要么在自己的岗位上发光发热，成为国家或者社会中无法被取代的一员；也可以选择成为文明探索的先锋，去突破当前的学术难题。</p><hr><h3 id="小小的规划"><a href="#小小的规划" class="headerlink" title="小小的规划"></a>小小的规划</h3><p>今天(2020年4月8日),算是这个博客正式营业的第一天,在这里先给自己定下一些目标和给自己一些约束，为后续的写文立下一些规范和保存一份习惯。</p><h4 id="给自己的约束"><a href="#给自己的约束" class="headerlink" title="给自己的约束"></a>给自己的约束</h4><h5 id="博客的更新频率"><a href="#博客的更新频率" class="headerlink" title="博客的更新频率"></a>博客的更新频率</h5><p>在我大学的时候其实就已经想经营一个技术博客，但是因为一些时间原因和个人原因，这个想法一直没有被落实，这也是一个小小的遗憾。但是现在一方面是时间比较充裕，二是所学技能需要沉淀，因此在开始的前几天会更新比较多的内容————补上大学时的坑和总结工作以来的技能。</p><h5 id="文档规范-期望"><a href="#文档规范-期望" class="headerlink" title="文档规范(期望)"></a>文档规范(期望)</h5><p>一、文档编写的时候要画思维导图<br>二、表格意识，加强对比<br>三、尽可能用容易理解的话来讲代码<br>四、不要写水文，尽可能多干货，结合自己地理解<br>五、写文内容以技术为主但不承诺只写技术相关内容<br>六、注重版权意识，引文或灵感来源要尊重原作者<br>七、下期预告</p><p>背景图片来自百度<a href="https://image.baidu.com/search/detail?ct=503316480&z=0&ipn=d&word=hello%20World&step_word=&hs=0&pn=0&spn=0&di=220&pi=0&rn=1&tn=baiduimagedetail&is=0%2C0&istype=0&ie=utf-8&oe=utf-8&in=&cl=2&lm=-1&st=undefined&cs=1905138384%2C486113505&os=2339458242%2C3019850321&simid=3382509924%2C256788667&adpicid=0&lpn=0&ln=1736&fr=&fmq=1586281832450_R&fm=&ic=undefined&s=undefined&hd=undefined&latest=undefined&copyright=undefined&se=&sme=&tab=0&width=undefined&height=undefined&face=undefined&ist=&jit=&cg=&bdtype=0&oriquery=&objurl=http%3A%2F%2Fi2.hdslb.com%2Fbfs%2Farchive%2F2209be24c1a5c0684a4b0771d04ce39b61e9db1a.jpg&fromurl=ippr_z2C%24qAzdH3FAzdH3Fooo_z%26e3Bdn9tgu5_z%26e3Bv54AzdH3FfAzdH3Fijss5%2Bo56s1&gsm=1&rpstart=0&rpnum=0&islist=&querylist=&force=undefined" target="_blank" rel="noopener">helloWorld</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hello-World&quot;&gt;&lt;a href=&quot;#Hello-World&quot; class=&quot;headerlink&quot; title=&quot;Hello World&quot;&gt;&lt;/a&gt;Hello World&lt;/h1&gt;&lt;h2 id=&quot;千里之行始于足下-前言&quot;&gt;&lt;a href=&quot;#千里之行始于
      
    
    </summary>
    
    
    
      <category term="helloWorld" scheme="http://ALEGANT.github.io/tags/helloWorld/"/>
    
      <category term="简介" scheme="http://ALEGANT.github.io/tags/%E7%AE%80%E4%BB%8B/"/>
    
  </entry>
  
</feed>
